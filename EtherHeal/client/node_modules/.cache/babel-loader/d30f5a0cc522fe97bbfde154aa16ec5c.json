{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst protons = require('protons');\n\nconst proto = protons(require('./dag.proto.js'));\n\nconst resolver = require('./resolver');\n\nconst DAGLink = require('./dag-link');\n\nconst DAGNode = require('./dag-node');\n\nconst multihashing = require('multihashing-async');\n\nconst waterfall = require('async/waterfall');\n\nexports = module.exports;\n/**\n * @callback CidCallback\n * @param {?Error} error - Error if getting the CID failed\n * @param {?CID} cid - CID if call was successful\n */\n\n/**\n * Get the CID of the DAG-Node.\n *\n * @param {Object} dagNode - Internal representation\n * @param {Object} [options] - Options to create the CID\n * @param {number} [options.version] - CID version number. Defaults to zero if hashAlg == 'sha2-256'; otherwise, 1.\n * @param {string} [options.hashAlg] - Defaults to hashAlg for the resolver\n * @param {CidCallback} callback - Callback that handles the return value\n * @returns {void}\n */\n\nfunction cid(dagNode, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  const hashAlg = options.hashAlg || resolver.defaultHashAlg;\n  let version = options.version;\n\n  if (typeof version === 'undefined') {\n    version = hashAlg === 'sha2-256' ? 0 : 1;\n  }\n\n  waterfall([cb => serialize(dagNode, cb), (serialized, cb) => multihashing(serialized, hashAlg, cb), (mh, cb) => cb(null, new CID(version, resolver.multicodec, mh))], callback);\n}\n\nfunction serialize(node, callback) {\n  let serialized; // If the node is not an instance of a DAGNode, the link.hash might be a Base58 encoded string; decode it\n\n  if (!DAGNode.isDAGNode(node) && node.links) {\n    node.links = node.links.map(link => {\n      return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link);\n    });\n  }\n\n  try {\n    serialized = proto.PBNode.encode(toProtoBuf(node));\n  } catch (err) {\n    return callback(err);\n  }\n\n  callback(null, serialized);\n}\n\nfunction deserialize(data, callback) {\n  const pbn = proto.PBNode.decode(data);\n  const links = pbn.Links.map(link => {\n    return new DAGLink(link.Name, link.Tsize, link.Hash);\n  });\n  const buf = pbn.Data == null ? Buffer.alloc(0) : Buffer.from(pbn.Data);\n  DAGNode.create(buf, links, callback);\n}\n\nfunction toProtoBuf(node) {\n  const pbn = {};\n\n  if (node.data && node.data.length > 0) {\n    pbn.Data = node.data;\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`\n    pbn.Data = null;\n  }\n\n  if (node.links && node.links.length > 0) {\n    pbn.Links = node.links.map(link => {\n      return {\n        Hash: link.multihash,\n        Name: link.name,\n        Tsize: link.size\n      };\n    });\n  } else {\n    pbn.Links = null;\n  }\n\n  return pbn;\n}\n\nexports.serialize = serialize;\nexports.deserialize = deserialize;\nexports.cid = cid;","map":{"version":3,"sources":["z:/Projects/EtherealOrgan-copy/Complete Project/client/node_modules/ipld-dag-pb/src/util.js"],"names":["CID","require","protons","proto","resolver","DAGLink","DAGNode","multihashing","waterfall","exports","module","cid","dagNode","options","callback","hashAlg","defaultHashAlg","version","cb","serialize","serialized","mh","multicodec","node","isDAGNode","links","map","link","isDAGLink","util","createDagLinkFromB58EncodedHash","PBNode","encode","toProtoBuf","err","deserialize","data","pbn","decode","Links","Name","Tsize","Hash","buf","Data","Buffer","alloc","from","create","length","multihash","name","size"],"mappings":"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","sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst protons = require('protons')\nconst proto = protons(require('./dag.proto.js'))\nconst resolver = require('./resolver')\nconst DAGLink = require('./dag-link')\nconst DAGNode = require('./dag-node')\nconst multihashing = require('multihashing-async')\nconst waterfall = require('async/waterfall')\n\nexports = module.exports\n\n/**\n * @callback CidCallback\n * @param {?Error} error - Error if getting the CID failed\n * @param {?CID} cid - CID if call was successful\n */\n/**\n * Get the CID of the DAG-Node.\n *\n * @param {Object} dagNode - Internal representation\n * @param {Object} [options] - Options to create the CID\n * @param {number} [options.version] - CID version number. Defaults to zero if hashAlg == 'sha2-256'; otherwise, 1.\n * @param {string} [options.hashAlg] - Defaults to hashAlg for the resolver\n * @param {CidCallback} callback - Callback that handles the return value\n * @returns {void}\n */\nfunction cid (dagNode, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  const hashAlg = options.hashAlg || resolver.defaultHashAlg\n  let version = options.version\n  if (typeof version === 'undefined') {\n    version = hashAlg === 'sha2-256' ? 0 : 1\n  }\n  waterfall([\n    (cb) => serialize(dagNode, cb),\n    (serialized, cb) => multihashing(serialized, hashAlg, cb),\n    (mh, cb) => cb(null, new CID(version, resolver.multicodec, mh))\n  ], callback)\n}\n\nfunction serialize (node, callback) {\n  let serialized\n\n  // If the node is not an instance of a DAGNode, the link.hash might be a Base58 encoded string; decode it\n  if (!DAGNode.isDAGNode(node) && node.links) {\n    node.links = node.links.map((link) => {\n      return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link)\n    })\n  }\n\n  try {\n    serialized = proto.PBNode.encode(toProtoBuf(node))\n  } catch (err) {\n    return callback(err)\n  }\n\n  callback(null, serialized)\n}\n\nfunction deserialize (data, callback) {\n  const pbn = proto.PBNode.decode(data)\n\n  const links = pbn.Links.map((link) => {\n    return new DAGLink(link.Name, link.Tsize, link.Hash)\n  })\n\n  const buf = pbn.Data == null ? Buffer.alloc(0) : Buffer.from(pbn.Data)\n\n  DAGNode.create(buf, links, callback)\n}\n\nfunction toProtoBuf (node) {\n  const pbn = {}\n\n  if (node.data && node.data.length > 0) {\n    pbn.Data = node.data\n  } else {\n    // NOTE: this has to be null in order to match go-ipfs serialization `null !== new Buffer(0)`\n    pbn.Data = null\n  }\n\n  if (node.links && node.links.length > 0) {\n    pbn.Links = node.links.map((link) => {\n      return {\n        Hash: link.multihash,\n        Name: link.name,\n        Tsize: link.size\n      }\n    })\n  } else {\n    pbn.Links = null\n  }\n\n  return pbn\n}\n\nexports.serialize = serialize\nexports.deserialize = deserialize\nexports.cid = cid\n"]},"metadata":{},"sourceType":"script"}