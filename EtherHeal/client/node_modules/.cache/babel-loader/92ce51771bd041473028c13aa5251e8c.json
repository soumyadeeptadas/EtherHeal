{"ast":null,"code":"'use strict';\n\nconst Duplex = require('stream').Duplex;\n\nconst eachSeries = require('async/eachSeries');\n\nconst isStream = require('is-stream');\n\nconst once = require('once');\n\nconst prepareFile = require('./prepare-file');\n\nconst Multipart = require('./multipart');\n\nfunction headers(file) {\n  const name = file.path ? encodeURIComponent(file.path) : '';\n  const header = {\n    'Content-Disposition': `file; filename=\"${name}\"`\n  };\n\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory';\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink';\n  } else {\n    header['Content-Type'] = 'application/octet-stream';\n  }\n\n  return header;\n}\n\nmodule.exports = (send, path) => {\n  return options => {\n    let request;\n    let ended = false;\n    let writing = false;\n    options = options ? Object.assign({}, options, options.qs) : {};\n    const multipart = new Multipart();\n    const retStream = new Duplex({\n      objectMode: true\n    });\n\n    retStream._read = n => {};\n\n    retStream._write = (file, enc, _next) => {\n      const next = once(_next);\n\n      try {\n        const files = prepareFile(file, options).map(file => Object.assign({\n          headers: headers(file)\n        }, file));\n        writing = true;\n        eachSeries(files, (file, cb) => multipart.write(file, enc, cb), err => {\n          writing = false;\n\n          if (err) {\n            return next(err);\n          }\n\n          if (ended) {\n            multipart.end();\n          }\n\n          next();\n        });\n      } catch (err) {\n        next(err);\n      }\n    };\n\n    retStream.once('finish', () => {\n      if (!ended) {\n        ended = true;\n\n        if (!writing) {\n          multipart.end();\n        }\n      }\n    });\n    const qs = options.qs || {};\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion');\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves');\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash');\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory');\n    qs.hash = propOrProp(options, 'hash', 'hashAlg');\n    const args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    };\n    multipart.on('error', err => {\n      retStream.emit('error', err);\n    });\n    request = send(args, (err, response) => {\n      if (err) {\n        return retStream.emit('error', err);\n      }\n\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null); // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response);\n        retStream.push(null);\n        return;\n      }\n\n      response.on('error', err => retStream.emit('error', err));\n\n      if (options.converter) {\n        response.on('data', d => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n        });\n        const Converter = options.converter;\n        const convertedResponse = new Converter();\n        convertedResponse.once('end', () => retStream.push(null));\n        convertedResponse.on('data', d => retStream.push(d));\n        response.pipe(convertedResponse);\n      } else {\n        response.on('data', d => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes);\n          }\n\n          retStream.push(d);\n        });\n        response.once('end', () => retStream.push(null));\n      }\n    }); // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n\n    request.on('drain', () => multipart.emit('drain'));\n    multipart.pipe(request);\n    return retStream;\n  };\n};\n\nfunction propOrProp(source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1];\n  } else if (prop2 in source) {\n    return source[prop2];\n  }\n}","map":{"version":3,"sources":["z:/Projects/EtherealOrgan-copy/Complete Project/client/node_modules/ipfs-api/src/utils/send-files-stream.js"],"names":["Duplex","require","eachSeries","isStream","once","prepareFile","Multipart","headers","file","name","path","encodeURIComponent","header","content","symlink","module","exports","send","options","request","ended","writing","Object","assign","qs","multipart","retStream","objectMode","_read","n","_write","enc","_next","next","files","map","cb","write","err","end","propOrProp","hash","args","multipartBoundary","_boundary","stream","recursive","progress","on","emit","response","push","converter","d","Bytes","Converter","convertedResponse","pipe","source","prop1","prop2"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Duplex = require('stream').Duplex\nconst eachSeries = require('async/eachSeries')\nconst isStream = require('is-stream')\nconst once = require('once')\nconst prepareFile = require('./prepare-file')\nconst Multipart = require('./multipart')\n\nfunction headers (file) {\n  const name = file.path\n    ? encodeURIComponent(file.path)\n    : ''\n\n  const header = { 'Content-Disposition': `file; filename=\"${name}\"` }\n\n  if (!file.content) {\n    header['Content-Type'] = 'application/x-directory'\n  } else if (file.symlink) {\n    header['Content-Type'] = 'application/symlink'\n  } else {\n    header['Content-Type'] = 'application/octet-stream'\n  }\n\n  return header\n}\n\nmodule.exports = (send, path) => {\n  return (options) => {\n    let request\n    let ended = false\n    let writing = false\n\n    options = options ? Object.assign({}, options, options.qs) : {}\n\n    const multipart = new Multipart()\n\n    const retStream = new Duplex({ objectMode: true })\n\n    retStream._read = (n) => {}\n\n    retStream._write = (file, enc, _next) => {\n      const next = once(_next)\n      try {\n        const files = prepareFile(file, options)\n          .map((file) => Object.assign({headers: headers(file)}, file))\n\n        writing = true\n        eachSeries(\n          files,\n          (file, cb) => multipart.write(file, enc, cb),\n          (err) => {\n            writing = false\n            if (err) {\n              return next(err)\n            }\n            if (ended) {\n              multipart.end()\n            }\n            next()\n          })\n      } catch (err) {\n        next(err)\n      }\n    }\n\n    retStream.once('finish', () => {\n      if (!ended) {\n        ended = true\n        if (!writing) {\n          multipart.end()\n        }\n      }\n    })\n\n    const qs = options.qs || {}\n\n    qs['cid-version'] = propOrProp(options, 'cid-version', 'cidVersion')\n    qs['raw-leaves'] = propOrProp(options, 'raw-leaves', 'rawLeaves')\n    qs['only-hash'] = propOrProp(options, 'only-hash', 'onlyHash')\n    qs['wrap-with-directory'] = propOrProp(options, 'wrap-with-directory', 'wrapWithDirectory')\n    qs.hash = propOrProp(options, 'hash', 'hashAlg')\n\n    const args = {\n      path: path,\n      qs: qs,\n      args: options.args,\n      multipart: true,\n      multipartBoundary: multipart._boundary,\n      stream: true,\n      recursive: true,\n      progress: options.progress\n    }\n\n    multipart.on('error', (err) => {\n      retStream.emit('error', err)\n    })\n\n    request = send(args, (err, response) => {\n      if (err) {\n        return retStream.emit('error', err)\n      }\n\n      if (!response) {\n        // no response, which means everything is ok, so we end the retStream\n        return retStream.push(null) // early\n      }\n\n      if (!isStream(response)) {\n        retStream.push(response)\n        retStream.push(null)\n        return\n      }\n\n      response.on('error', (err) => retStream.emit('error', err))\n\n      if (options.converter) {\n        response.on('data', (d) => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes)\n          }\n        })\n\n        const Converter = options.converter\n        const convertedResponse = new Converter()\n        convertedResponse.once('end', () => retStream.push(null))\n        convertedResponse.on('data', (d) => retStream.push(d))\n        response.pipe(convertedResponse)\n      } else {\n        response.on('data', (d) => {\n          if (d.Bytes && options.progress) {\n            options.progress(d.Bytes)\n          }\n          retStream.push(d)\n        })\n        response.once('end', () => retStream.push(null))\n      }\n    })\n\n    // signal the multipart that the underlying stream has drained and that\n    // it can continue producing data..\n    request.on('drain', () => multipart.emit('drain'))\n\n    multipart.pipe(request)\n\n    return retStream\n  }\n}\n\nfunction propOrProp (source, prop1, prop2) {\n  if (prop1 in source) {\n    return source[prop1]\n  } else if (prop2 in source) {\n    return source[prop2]\n  }\n}\n"]},"metadata":{},"sourceType":"script"}