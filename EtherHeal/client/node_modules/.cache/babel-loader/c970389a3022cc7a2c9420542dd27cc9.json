{"ast":null,"code":"'use strict';\n\nconst ensureMultiaddr = require('./utils').ensureMultiaddr;\n\nconst uniqBy = require('lodash.uniqby'); // Because JavaScript doesn't let you overload the compare in Set()..\n\n\nclass MultiaddrSet {\n  constructor(multiaddrs) {\n    this._multiaddrs = multiaddrs || [];\n    this._observedMultiaddrs = [];\n  }\n\n  add(ma) {\n    ma = ensureMultiaddr(ma);\n\n    if (!this.has(ma)) {\n      this._multiaddrs.push(ma);\n    }\n  } // addSafe - prevent multiaddr explosion™\n  // Multiaddr explosion is when you dial to a bunch of nodes and every node\n  // gives you a different observed address and you start storing them all to\n  // share with other peers. This seems like a good idea until you realize that\n  // most of those addresses are unique to the subnet that peer is in and so,\n  // they are completely worthless for all the other peers. This method is\n  // exclusively used by identify.\n\n\n  addSafe(ma) {\n    ma = ensureMultiaddr(ma);\n\n    const check = this._observedMultiaddrs.some((m, i) => {\n      if (m.equals(ma)) {\n        this.add(ma);\n\n        this._observedMultiaddrs.splice(i, 1);\n\n        return true;\n      }\n    });\n\n    if (!check) {\n      this._observedMultiaddrs.push(ma);\n    }\n  }\n\n  toArray() {\n    return this._multiaddrs.slice();\n  }\n\n  get size() {\n    return this._multiaddrs.length;\n  }\n\n  forEach(fn) {\n    return this._multiaddrs.forEach(fn);\n  }\n\n  filterBy(maFmt) {\n    if (typeof maFmt !== 'object' || typeof maFmt.matches !== 'function' || typeof maFmt.partialMatch !== 'function' || typeof maFmt.toString !== 'function') return [];\n    return this._multiaddrs.filter(ma => maFmt.matches(ma));\n  }\n\n  has(ma) {\n    ma = ensureMultiaddr(ma);\n    return this._multiaddrs.some(m => m.equals(ma));\n  }\n\n  delete(ma) {\n    ma = ensureMultiaddr(ma);\n\n    this._multiaddrs.some((m, i) => {\n      if (m.equals(ma)) {\n        this._multiaddrs.splice(i, 1);\n\n        return true;\n      }\n    });\n  } // replaces selected existing multiaddrs with new ones\n\n\n  replace(existing, fresh) {\n    if (!Array.isArray(existing)) {\n      existing = [existing];\n    }\n\n    if (!Array.isArray(fresh)) {\n      fresh = [fresh];\n    }\n\n    existing.forEach(m => this.delete(m));\n    fresh.forEach(m => this.add(m));\n  }\n\n  clear() {\n    this._multiaddrs = [];\n  } // this only really helps make ip6 and ip4 multiaddrs distinct if they are\n  // different\n  // TODO this is not an ideal solution, probably this code should just be\n  // in libp2p-tcp\n\n\n  distinct() {\n    return uniqBy(this._multiaddrs, ma => {\n      return [ma.toOptions().port, ma.toOptions().transport].join();\n    });\n  }\n\n}\n\nmodule.exports = MultiaddrSet;","map":{"version":3,"sources":["Z:/Projects/Organ-Donation-Transplant-Chain-master/Complete Project/client/node_modules/peer-info/src/multiaddr-set.js"],"names":["ensureMultiaddr","require","uniqBy","MultiaddrSet","constructor","multiaddrs","_multiaddrs","_observedMultiaddrs","add","ma","has","push","addSafe","check","some","m","i","equals","splice","toArray","slice","size","length","forEach","fn","filterBy","maFmt","matches","partialMatch","toString","filter","delete","replace","existing","fresh","Array","isArray","clear","distinct","toOptions","port","transport","join","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst ensureMultiaddr = require('./utils').ensureMultiaddr\nconst uniqBy = require('lodash.uniqby')\n\n// Because JavaScript doesn't let you overload the compare in Set()..\nclass MultiaddrSet {\n  constructor (multiaddrs) {\n    this._multiaddrs = multiaddrs || []\n    this._observedMultiaddrs = []\n  }\n\n  add (ma) {\n    ma = ensureMultiaddr(ma)\n\n    if (!this.has(ma)) {\n      this._multiaddrs.push(ma)\n    }\n  }\n\n  // addSafe - prevent multiaddr explosion™\n  // Multiaddr explosion is when you dial to a bunch of nodes and every node\n  // gives you a different observed address and you start storing them all to\n  // share with other peers. This seems like a good idea until you realize that\n  // most of those addresses are unique to the subnet that peer is in and so,\n  // they are completely worthless for all the other peers. This method is\n  // exclusively used by identify.\n  addSafe (ma) {\n    ma = ensureMultiaddr(ma)\n\n    const check = this._observedMultiaddrs.some((m, i) => {\n      if (m.equals(ma)) {\n        this.add(ma)\n        this._observedMultiaddrs.splice(i, 1)\n        return true\n      }\n    })\n    if (!check) {\n      this._observedMultiaddrs.push(ma)\n    }\n  }\n\n  toArray () {\n    return this._multiaddrs.slice()\n  }\n\n  get size () {\n    return this._multiaddrs.length\n  }\n\n  forEach (fn) {\n    return this._multiaddrs.forEach(fn)\n  }\n\n  filterBy (maFmt) {\n    if (typeof maFmt !== 'object' ||\n      typeof maFmt.matches !== 'function' ||\n      typeof maFmt.partialMatch !== 'function' ||\n      typeof maFmt.toString !== 'function') return []\n\n    return this._multiaddrs.filter((ma) => maFmt.matches(ma))\n  }\n\n  has (ma) {\n    ma = ensureMultiaddr(ma)\n    return this._multiaddrs.some((m) => m.equals(ma))\n  }\n\n  delete (ma) {\n    ma = ensureMultiaddr(ma)\n\n    this._multiaddrs.some((m, i) => {\n      if (m.equals(ma)) {\n        this._multiaddrs.splice(i, 1)\n        return true\n      }\n    })\n  }\n\n  // replaces selected existing multiaddrs with new ones\n  replace (existing, fresh) {\n    if (!Array.isArray(existing)) {\n      existing = [existing]\n    }\n    if (!Array.isArray(fresh)) {\n      fresh = [fresh]\n    }\n    existing.forEach((m) => this.delete(m))\n    fresh.forEach((m) => this.add(m))\n  }\n\n  clear () {\n    this._multiaddrs = []\n  }\n\n  // this only really helps make ip6 and ip4 multiaddrs distinct if they are\n  // different\n  // TODO this is not an ideal solution, probably this code should just be\n  // in libp2p-tcp\n  distinct () {\n    return uniqBy(this._multiaddrs, (ma) => {\n      return [ma.toOptions().port, ma.toOptions().transport].join()\n    })\n  }\n}\n\nmodule.exports = MultiaddrSet\n"]},"metadata":{},"sourceType":"script"}