{"ast":null,"code":"// The RLP format\n// Serialization and deserialization for the BytesTree type, under the following grammar:\n// | First byte | Meaning                                                                    |\n// | ---------- | -------------------------------------------------------------------------- |\n// | 0   to 127 | HEX(leaf)                                                                  |\n// | 128 to 183 | HEX(length_of_leaf + 128) + HEX(leaf)                                      |\n// | 184 to 191 | HEX(length_of_length_of_leaf + 128 + 55) + HEX(length_of_leaf) + HEX(leaf) |\n// | 192 to 247 | HEX(length_of_node + 192) + HEX(node)                                      |\n// | 248 to 255 | HEX(length_of_length_of_node + 128 + 55) + HEX(length_of_node) + HEX(node) |\nvar encode = function encode(tree) {\n  var padEven = function padEven(str) {\n    return str.length % 2 === 0 ? str : \"0\" + str;\n  };\n\n  var uint = function uint(num) {\n    return padEven(num.toString(16));\n  };\n\n  var length = function length(len, add) {\n    return len < 56 ? uint(add + len) : uint(add + uint(len).length / 2 + 55) + uint(len);\n  };\n\n  var dataTree = function dataTree(tree) {\n    if (typeof tree === \"string\") {\n      var hex = tree.slice(2);\n      var pre = hex.length != 2 || hex >= \"80\" ? length(hex.length / 2, 128) : \"\";\n      return pre + hex;\n    } else {\n      var _hex = tree.map(dataTree).join(\"\");\n\n      var _pre = length(_hex.length / 2, 192);\n\n      return _pre + _hex;\n    }\n  };\n\n  return \"0x\" + dataTree(tree);\n};\n\nvar decode = function decode(hex) {\n  var i = 2;\n\n  var parseTree = function parseTree() {\n    if (i >= hex.length) throw \"\";\n    var head = hex.slice(i, i + 2);\n    return head < \"80\" ? (i += 2, \"0x\" + head) : head < \"c0\" ? parseHex() : parseList();\n  };\n\n  var parseLength = function parseLength() {\n    var len = parseInt(hex.slice(i, i += 2), 16) % 64;\n    return len < 56 ? len : parseInt(hex.slice(i, i += (len - 55) * 2), 16);\n  };\n\n  var parseHex = function parseHex() {\n    var len = parseLength();\n    return \"0x\" + hex.slice(i, i += len * 2);\n  };\n\n  var parseList = function parseList() {\n    var lim = parseLength() * 2 + i;\n    var list = [];\n\n    while (i < lim) {\n      list.push(parseTree());\n    }\n\n    return list;\n  };\n\n  try {\n    return parseTree();\n  } catch (e) {\n    return [];\n  }\n};\n\nmodule.exports = {\n  encode: encode,\n  decode: decode\n};","map":{"version":3,"sources":["z:/Projects/EtherealOrgan/Complete Project/client/node_modules/eth-lib/lib/rlp.js"],"names":["encode","tree","padEven","str","length","uint","num","toString","len","add","dataTree","hex","slice","pre","_hex","map","join","_pre","decode","i","parseTree","head","parseHex","parseList","parseLength","parseInt","lim","list","push","e","module","exports"],"mappings":"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","sourcesContent":["// The RLP format\n// Serialization and deserialization for the BytesTree type, under the following grammar:\n// | First byte | Meaning                                                                    |\n// | ---------- | -------------------------------------------------------------------------- |\n// | 0   to 127 | HEX(leaf)                                                                  |\n// | 128 to 183 | HEX(length_of_leaf + 128) + HEX(leaf)                                      |\n// | 184 to 191 | HEX(length_of_length_of_leaf + 128 + 55) + HEX(length_of_leaf) + HEX(leaf) |\n// | 192 to 247 | HEX(length_of_node + 192) + HEX(node)                                      |\n// | 248 to 255 | HEX(length_of_length_of_node + 128 + 55) + HEX(length_of_node) + HEX(node) |\n\nvar encode = function encode(tree) {\n  var padEven = function padEven(str) {\n    return str.length % 2 === 0 ? str : \"0\" + str;\n  };\n\n  var uint = function uint(num) {\n    return padEven(num.toString(16));\n  };\n\n  var length = function length(len, add) {\n    return len < 56 ? uint(add + len) : uint(add + uint(len).length / 2 + 55) + uint(len);\n  };\n\n  var dataTree = function dataTree(tree) {\n    if (typeof tree === \"string\") {\n      var hex = tree.slice(2);\n      var pre = hex.length != 2 || hex >= \"80\" ? length(hex.length / 2, 128) : \"\";\n      return pre + hex;\n    } else {\n      var _hex = tree.map(dataTree).join(\"\");\n      var _pre = length(_hex.length / 2, 192);\n      return _pre + _hex;\n    }\n  };\n\n  return \"0x\" + dataTree(tree);\n};\n\nvar decode = function decode(hex) {\n  var i = 2;\n\n  var parseTree = function parseTree() {\n    if (i >= hex.length) throw \"\";\n    var head = hex.slice(i, i + 2);\n    return head < \"80\" ? (i += 2, \"0x\" + head) : head < \"c0\" ? parseHex() : parseList();\n  };\n\n  var parseLength = function parseLength() {\n    var len = parseInt(hex.slice(i, i += 2), 16) % 64;\n    return len < 56 ? len : parseInt(hex.slice(i, i += (len - 55) * 2), 16);\n  };\n\n  var parseHex = function parseHex() {\n    var len = parseLength();\n    return \"0x\" + hex.slice(i, i += len * 2);\n  };\n\n  var parseList = function parseList() {\n    var lim = parseLength() * 2 + i;\n    var list = [];\n    while (i < lim) {\n      list.push(parseTree());\n    }return list;\n  };\n\n  try {\n    return parseTree();\n  } catch (e) {\n    return [];\n  }\n};\n\nmodule.exports = { encode: encode, decode: decode };"]},"metadata":{},"sourceType":"script"}