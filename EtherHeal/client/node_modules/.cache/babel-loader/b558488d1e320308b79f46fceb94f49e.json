{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nconst mh = require('multihashes');\n\nconst crypto = require('libp2p-crypto');\n\nconst assert = require('assert');\n\nconst waterfall = require('async/waterfall');\n\nclass PeerId {\n  constructor(id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided');\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = mh.toB58String(this.id);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  set id(val) {\n    throw new Error('Id is immutable');\n  }\n\n  get privKey() {\n    return this._privKey;\n  }\n\n  set privKey(privKey) {\n    this._privKey = privKey;\n  }\n\n  get pubKey() {\n    if (this._pubKey) {\n      return this._pubKey;\n    }\n\n    if (this._privKey) {\n      return this._privKey.public;\n    }\n  }\n\n  set pubKey(pubKey) {\n    this._pubKey = pubKey;\n  } // Return the protobuf version of the public key, matching go ipfs formatting\n\n\n  marshalPubKey() {\n    if (this.pubKey) {\n      return crypto.keys.marshalPublicKey(this.pubKey);\n    }\n  } // Return the protobuf version of the private key, matching go ipfs formatting\n\n\n  marshalPrivKey() {\n    if (this.privKey) {\n      return crypto.keys.marshalPrivateKey(this.privKey);\n    }\n  } // pretty print\n\n\n  toPrint() {\n    return this.toJSON();\n  } // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n\n\n  toJSON() {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    };\n  } // encode/decode functions\n\n\n  toHexString() {\n    return mh.toHexString(this.id);\n  }\n\n  toBytes() {\n    return this.id;\n  }\n\n  toB58String() {\n    return this._idB58String;\n  }\n\n  isEqual(id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id);\n    } else if (id.id) {\n      return this.id.equals(id.id);\n    } else {\n      throw new Error('not valid Id');\n    }\n  }\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n\n\n  isValid(callback) {\n    // TODO Needs better checking\n    if (this.privKey && this.privKey.public && this.privKey.public.bytes && Buffer.isBuffer(this.pubKey.bytes) && this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback();\n    } else {\n      callback(new Error('Keys not match'));\n    }\n  }\n\n}\n\nexports = module.exports = PeerId; // generation\n\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n  opts.bits = opts.bits || 2048;\n  waterfall([cb => crypto.keys.generateKeyPair('RSA', opts.bits, cb), (privKey, cb) => privKey.public.hash((err, digest) => {\n    cb(err, digest, privKey);\n  })], (err, digest, privKey) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new PeerId(digest, privKey));\n  });\n};\n\nexports.createFromHexString = function (str) {\n  return new PeerId(mh.fromHexString(str));\n};\n\nexports.createFromBytes = function (buf) {\n  return new PeerId(buf);\n};\n\nexports.createFromB58String = function (str) {\n  return new PeerId(mh.fromB58String(str));\n}; // Public Key input will be a buffer\n\n\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let pubKey;\n\n  try {\n    let buf = key;\n\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n    pubKey = crypto.keys.unmarshalPublicKey(buf);\n  } catch (err) {\n    return callback(err);\n  }\n\n  pubKey.hash((err, digest) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new PeerId(digest, null, pubKey));\n  });\n}; // Private key input will be a string\n\n\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let buf = key;\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n  } catch (err) {\n    return callback(err);\n  }\n\n  waterfall([cb => crypto.keys.unmarshalPrivateKey(buf, cb), (privKey, cb) => privKey.public.hash((err, digest) => {\n    cb(err, digest, privKey);\n  })], (err, digest, privKey) => {\n    if (err) {\n      return callback(err);\n    }\n\n    callback(null, new PeerId(digest, privKey, privKey.public));\n  });\n};\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let id;\n  let rawPrivKey;\n  let rawPubKey;\n  let pub;\n\n  try {\n    id = mh.fromB58String(obj.id);\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64');\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64');\n    pub = rawPubKey && crypto.keys.unmarshalPublicKey(rawPubKey);\n  } catch (err) {\n    return callback(err);\n  }\n\n  if (rawPrivKey) {\n    waterfall([cb => crypto.keys.unmarshalPrivateKey(rawPrivKey, cb), (priv, cb) => priv.public.hash((err, digest) => {\n      cb(err, digest, priv);\n    }), (privDigest, priv, cb) => {\n      if (pub) {\n        pub.hash((err, pubDigest) => {\n          cb(err, privDigest, priv, pubDigest);\n        });\n      } else {\n        cb(null, privDigest, priv);\n      }\n    }], (err, privDigest, priv, pubDigest) => {\n      if (err) {\n        return callback(err);\n      }\n\n      if (pub && !privDigest.equals(pubDigest)) {\n        return callback(new Error('Public and private key do not match'));\n      }\n\n      if (id && !privDigest.equals(id)) {\n        return callback(new Error('Id and private key do not match'));\n      }\n\n      callback(null, new PeerId(id, priv, pub));\n    });\n  } else {\n    callback(null, new PeerId(id, null, pub));\n  }\n};\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return val.toString('base64');\n  }\n}","map":{"version":3,"sources":["Z:/Projects/Rakuten Hack/EtherealHeal/Complete Project/client/node_modules/peer-info/node_modules/peer-id/src/index.js"],"names":["mh","require","crypto","assert","waterfall","PeerId","constructor","id","privKey","pubKey","Buffer","isBuffer","public","bytes","equals","_id","_idB58String","toB58String","_privKey","_pubKey","val","Error","marshalPubKey","keys","marshalPublicKey","marshalPrivKey","marshalPrivateKey","toPrint","toJSON","toB64Opt","toHexString","toBytes","isEqual","isValid","callback","exports","module","create","opts","bits","cb","generateKeyPair","hash","err","digest","createFromHexString","str","fromHexString","createFromBytes","buf","createFromB58String","fromB58String","createFromPubKey","key","from","unmarshalPublicKey","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","rawPrivKey","rawPubKey","pub","priv","privDigest","pubDigest","isPeerId","peerId","Boolean","toString"],"mappings":"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","sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst mh = require('multihashes')\nconst crypto = require('libp2p-crypto')\nconst assert = require('assert')\nconst waterfall = require('async/waterfall')\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided')\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = mh.toB58String(this.id)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return crypto.keys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return crypto.keys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  // pretty print\n  toPrint () {\n    return this.toJSON()\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return mh.toHexString(this.id)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  isEqual (id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id)\n    } else if (id.id) {\n      return this.id.equals(id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid (callback) {\n    // TODO Needs better checking\n    if (this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      Buffer.isBuffer(this.pubKey.bytes) &&\n      this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback()\n    } else {\n      callback(new Error('Keys not match'))\n    }\n  }\n}\n\nexports = module.exports = PeerId\n\n// generation\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  }\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n\n  waterfall([\n    (cb) => crypto.keys.generateKeyPair('RSA', opts.bits, cb),\n    (privKey, cb) => privKey.public.hash((err, digest) => {\n      cb(err, digest, privKey)\n    })\n  ], (err, digest, privKey) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new PeerId(digest, privKey))\n  })\n}\n\nexports.createFromHexString = function (str) {\n  return new PeerId(mh.fromHexString(str))\n}\n\nexports.createFromBytes = function (buf) {\n  return new PeerId(buf)\n}\n\nexports.createFromB58String = function (str) {\n  return new PeerId(mh.fromB58String(str))\n}\n\n// Public Key input will be a buffer\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let pubKey\n\n  try {\n    let buf = key\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n\n    pubKey = crypto.keys.unmarshalPublicKey(buf)\n  } catch (err) {\n    return callback(err)\n  }\n\n  pubKey.hash((err, digest) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new PeerId(digest, null, pubKey))\n  })\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let buf = key\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n  } catch (err) {\n    return callback(err)\n  }\n\n  waterfall([\n    (cb) => crypto.keys.unmarshalPrivateKey(buf, cb),\n    (privKey, cb) => privKey.public.hash((err, digest) => {\n      cb(err, digest, privKey)\n    })\n  ], (err, digest, privKey) => {\n    if (err) {\n      return callback(err)\n    }\n\n    callback(null, new PeerId(digest, privKey, privKey.public))\n  })\n}\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let id\n  let rawPrivKey\n  let rawPubKey\n  let pub\n\n  try {\n    id = mh.fromB58String(obj.id)\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64')\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64')\n    pub = rawPubKey && crypto.keys.unmarshalPublicKey(rawPubKey)\n  } catch (err) {\n    return callback(err)\n  }\n\n  if (rawPrivKey) {\n    waterfall([\n      (cb) => crypto.keys.unmarshalPrivateKey(rawPrivKey, cb),\n      (priv, cb) => priv.public.hash((err, digest) => {\n        cb(err, digest, priv)\n      }),\n      (privDigest, priv, cb) => {\n        if (pub) {\n          pub.hash((err, pubDigest) => {\n            cb(err, privDigest, priv, pubDigest)\n          })\n        } else {\n          cb(null, privDigest, priv)\n        }\n      }\n    ], (err, privDigest, priv, pubDigest) => {\n      if (err) {\n        return callback(err)\n      }\n\n      if (pub && !privDigest.equals(pubDigest)) {\n        return callback(new Error('Public and private key do not match'))\n      }\n\n      if (id && !privDigest.equals(id)) {\n        return callback(new Error('Id and private key do not match'))\n      }\n\n      callback(null, new PeerId(id, priv, pub))\n    })\n  } else {\n    callback(null, new PeerId(id, null, pub))\n  }\n}\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return val.toString('base64')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}