{"ast":null,"code":"'use strict';\n\nconst Qs = require('qs');\n\nconst qsDefaultEncoder = require('qs/lib/utils').encode;\n\nconst isNode = require('detect-node');\n\nconst ndjson = require('ndjson');\n\nconst pump = require('pump');\n\nconst once = require('once');\n\nconst streamToValue = require('./stream-to-value');\n\nconst streamToJsonValue = require('./stream-to-json-value');\n\nconst request = require('./request');\n\nconst log = require('debug')('ipfs-api:request'); // -- Internal\n\n\nfunction parseError(res, cb) {\n  const error = new Error(`Server responded with ${res.statusCode}`);\n  streamToJsonValue(res, (err, payload) => {\n    if (err) {\n      return cb(err);\n    }\n\n    if (payload) {\n      error.code = payload.Code;\n      error.message = payload.Message || payload.toString();\n      error.type = payload.Type;\n    }\n\n    cb(error);\n  });\n}\n\nfunction onRes(buffer, cb) {\n  return res => {\n    const stream = Boolean(res.headers['x-stream-output']);\n    const chunkedObjects = Boolean(res.headers['x-chunked-output']);\n    const isJson = res.headers['content-type'] && res.headers['content-type'].indexOf('application/json') === 0;\n\n    if (res.req) {\n      log(res.req.method, `${res.req.getHeaders().host}${res.req.path}`, res.statusCode, res.statusMessage);\n    } else {\n      log(res.url, res.statusCode, res.statusMessage);\n    }\n\n    if (res.statusCode >= 400 || !res.statusCode) {\n      return parseError(res, cb);\n    } // Return the response stream directly\n\n\n    if (stream && !buffer) {\n      return cb(null, res);\n    } // Return a stream of JSON objects\n\n\n    if (chunkedObjects && isJson) {\n      const outputStream = ndjson.parse();\n      pump(res, outputStream);\n      res.on('end', () => {\n        let err = res.trailers['x-stream-error'];\n\n        if (err) {\n          // Not all errors are JSON\n          try {\n            err = JSON.parse(err);\n          } catch (e) {\n            err = {\n              Message: err\n            };\n          }\n\n          outputStream.emit('error', new Error(err.Message));\n        }\n      });\n      return cb(null, outputStream);\n    } // Return a JSON object\n\n\n    if (isJson) {\n      return streamToJsonValue(res, cb);\n    } // Return a value\n\n\n    return streamToValue(res, cb);\n  };\n}\n\nfunction requestAPI(config, options, callback) {\n  callback = once(callback);\n  options.qs = options.qs || {};\n\n  if (Array.isArray(options.path)) {\n    options.path = options.path.join('/');\n  }\n\n  if (options.args && !Array.isArray(options.args)) {\n    options.args = [options.args];\n  }\n\n  if (options.args) {\n    options.qs.arg = options.args;\n  }\n\n  if (options.progress) {\n    options.qs.progress = true;\n  }\n\n  if (options.qs.r) {\n    options.qs.recursive = options.qs.r; // From IPFS 0.4.0, it throws an error when both r and recursive are passed\n\n    delete options.qs.r;\n  }\n\n  options.qs['stream-channels'] = true;\n\n  if (options.stream) {\n    options.buffer = false;\n  } // this option is only used internally, not passed to daemon\n\n\n  delete options.qs.followSymlinks;\n  const method = 'POST';\n  const headers = Object.assign({}, config.headers);\n\n  if (isNode) {\n    // Browsers do not allow you to modify the user agent\n    headers['User-Agent'] = config['user-agent'];\n  }\n\n  if (options.multipart) {\n    if (!options.multipartBoundary) {\n      return callback(new Error('No multipartBoundary'));\n    }\n\n    headers['Content-Type'] = `multipart/form-data; boundary=${options.multipartBoundary}`;\n  }\n\n  const qs = Qs.stringify(options.qs, {\n    arrayFormat: 'repeat',\n    encoder: data => {\n      // TODO: future releases of qs will provide the default\n      // encoder as a 2nd argument to this function; it will\n      // no longer be necessary to import qsDefaultEncoder\n      if (Buffer.isBuffer(data)) {\n        let uriEncoded = '';\n\n        for (const byte of data) {\n          // https://tools.ietf.org/html/rfc3986#page-14\n          // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E)\n          if (byte >= 0x41 && byte <= 0x5A || byte >= 0x61 && byte <= 0x7A || byte >= 0x30 && byte <= 0x39 || byte === 0x2D || byte === 0x2E || byte === 0x5F || byte === 0x7E) {\n            uriEncoded += String.fromCharCode(byte);\n          } else {\n            const hex = byte.toString(16); // String.prototype.padStart() not widely supported yet\n\n            const padded = hex.length === 1 ? `0${hex}` : hex;\n            uriEncoded += `%${padded}`;\n          }\n        }\n\n        return uriEncoded;\n      }\n\n      return qsDefaultEncoder(data);\n    }\n  });\n  const reqOptions = {\n    hostname: config.host,\n    path: `${config['api-path']}${options.path}?${qs}`,\n    port: config.port,\n    method: method,\n    headers: headers,\n    protocol: `${config.protocol}:`\n  };\n  const req = request(config.protocol)(reqOptions, onRes(options.buffer, callback));\n  req.on('error', err => {\n    callback(err);\n  });\n\n  if (!options.stream) {\n    req.end();\n  }\n\n  return req;\n} //\n// -- Module Interface\n\n\nexports = module.exports = config => {\n  /*\n   * options: {\n   *   path:   // API path (like /add or /config) - type: string\n   *   args:   // Arguments to the command - type: object\n   *   qs:     // Opts as query string opts to the command --something - type: object\n   *   files:  // files to be sent - type: string, buffer or array of strings or buffers\n   *   buffer: // buffer the request before sending it - type: bool\n   * }\n   */\n  const send = (options, callback) => {\n    if (typeof options !== 'object') {\n      return callback(new Error('no options were passed'));\n    }\n\n    return requestAPI(config, options, callback);\n  }; // Send a HTTP request and pass via a transform function\n  // to convert the response data to wanted format before\n  // returning it to the callback.\n  // Eg. send.andTransform({}, (e) => JSON.parse(e), (err, res) => ...)\n\n\n  send.andTransform = (options, transform, callback) => {\n    return send(options, (err, res) => {\n      if (err) {\n        return callback(err);\n      }\n\n      transform(res, callback);\n    });\n  };\n\n  return send;\n};","map":{"version":3,"sources":["z:/Projects/EtherealOrgan/Complete Project/client/node_modules/ipfs-api/src/utils/send-request.js"],"names":["Qs","require","qsDefaultEncoder","encode","isNode","ndjson","pump","once","streamToValue","streamToJsonValue","request","log","parseError","res","cb","error","Error","statusCode","err","payload","code","Code","message","Message","toString","type","Type","onRes","buffer","stream","Boolean","headers","chunkedObjects","isJson","indexOf","req","method","getHeaders","host","path","statusMessage","url","outputStream","parse","on","trailers","JSON","e","emit","requestAPI","config","options","callback","qs","Array","isArray","join","args","arg","progress","r","recursive","followSymlinks","Object","assign","multipart","multipartBoundary","stringify","arrayFormat","encoder","data","Buffer","isBuffer","uriEncoded","byte","String","fromCharCode","hex","padded","length","reqOptions","hostname","port","protocol","end","exports","module","send","andTransform","transform"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,cAAD,CAAP,CAAwBE,MAAjD;;AACA,MAAMC,MAAM,GAAGH,OAAO,CAAC,aAAD,CAAtB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMK,IAAI,GAAGL,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMM,IAAI,GAAGN,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMO,aAAa,GAAGP,OAAO,CAAC,mBAAD,CAA7B;;AACA,MAAMQ,iBAAiB,GAAGR,OAAO,CAAC,wBAAD,CAAjC;;AACA,MAAMS,OAAO,GAAGT,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMU,GAAG,GAAGV,OAAO,CAAC,OAAD,CAAP,CAAiB,kBAAjB,CAAZ,C,CAEA;;;AAEA,SAASW,UAAT,CAAqBC,GAArB,EAA0BC,EAA1B,EAA8B;AAC5B,QAAMC,KAAK,GAAG,IAAIC,KAAJ,CAAW,yBAAwBH,GAAG,CAACI,UAAW,EAAlD,CAAd;AAEAR,EAAAA,iBAAiB,CAACI,GAAD,EAAM,CAACK,GAAD,EAAMC,OAAN,KAAkB;AACvC,QAAID,GAAJ,EAAS;AACP,aAAOJ,EAAE,CAACI,GAAD,CAAT;AACD;;AAED,QAAIC,OAAJ,EAAa;AACXJ,MAAAA,KAAK,CAACK,IAAN,GAAaD,OAAO,CAACE,IAArB;AACAN,MAAAA,KAAK,CAACO,OAAN,GAAgBH,OAAO,CAACI,OAAR,IAAmBJ,OAAO,CAACK,QAAR,EAAnC;AACAT,MAAAA,KAAK,CAACU,IAAN,GAAaN,OAAO,CAACO,IAArB;AACD;;AACDZ,IAAAA,EAAE,CAACC,KAAD,CAAF;AACD,GAXgB,CAAjB;AAYD;;AAED,SAASY,KAAT,CAAgBC,MAAhB,EAAwBd,EAAxB,EAA4B;AAC1B,SAAQD,GAAD,IAAS;AACd,UAAMgB,MAAM,GAAGC,OAAO,CAACjB,GAAG,CAACkB,OAAJ,CAAY,iBAAZ,CAAD,CAAtB;AACA,UAAMC,cAAc,GAAGF,OAAO,CAACjB,GAAG,CAACkB,OAAJ,CAAY,kBAAZ,CAAD,CAA9B;AACA,UAAME,MAAM,GAAGpB,GAAG,CAACkB,OAAJ,CAAY,cAAZ,KACAlB,GAAG,CAACkB,OAAJ,CAAY,cAAZ,EAA4BG,OAA5B,CAAoC,kBAApC,MAA4D,CAD3E;;AAGA,QAAIrB,GAAG,CAACsB,GAAR,EAAa;AACXxB,MAAAA,GAAG,CAACE,GAAG,CAACsB,GAAJ,CAAQC,MAAT,EAAkB,GAAEvB,GAAG,CAACsB,GAAJ,CAAQE,UAAR,GAAqBC,IAAK,GAAEzB,GAAG,CAACsB,GAAJ,CAAQI,IAAK,EAA7D,EAAgE1B,GAAG,CAACI,UAApE,EAAgFJ,GAAG,CAAC2B,aAApF,CAAH;AACD,KAFD,MAEO;AACL7B,MAAAA,GAAG,CAACE,GAAG,CAAC4B,GAAL,EAAU5B,GAAG,CAACI,UAAd,EAA0BJ,GAAG,CAAC2B,aAA9B,CAAH;AACD;;AAED,QAAI3B,GAAG,CAACI,UAAJ,IAAkB,GAAlB,IAAyB,CAACJ,GAAG,CAACI,UAAlC,EAA8C;AAC5C,aAAOL,UAAU,CAACC,GAAD,EAAMC,EAAN,CAAjB;AACD,KAda,CAgBd;;;AACA,QAAIe,MAAM,IAAI,CAACD,MAAf,EAAuB;AACrB,aAAOd,EAAE,CAAC,IAAD,EAAOD,GAAP,CAAT;AACD,KAnBa,CAqBd;;;AACA,QAAImB,cAAc,IAAIC,MAAtB,EAA8B;AAC5B,YAAMS,YAAY,GAAGrC,MAAM,CAACsC,KAAP,EAArB;AACArC,MAAAA,IAAI,CAACO,GAAD,EAAM6B,YAAN,CAAJ;AACA7B,MAAAA,GAAG,CAAC+B,EAAJ,CAAO,KAAP,EAAc,MAAM;AAClB,YAAI1B,GAAG,GAAGL,GAAG,CAACgC,QAAJ,CAAa,gBAAb,CAAV;;AACA,YAAI3B,GAAJ,EAAS;AACP;AACA,cAAI;AACFA,YAAAA,GAAG,GAAG4B,IAAI,CAACH,KAAL,CAAWzB,GAAX,CAAN;AACD,WAFD,CAEE,OAAO6B,CAAP,EAAU;AACV7B,YAAAA,GAAG,GAAG;AAAEK,cAAAA,OAAO,EAAEL;AAAX,aAAN;AACD;;AACDwB,UAAAA,YAAY,CAACM,IAAb,CAAkB,OAAlB,EAA2B,IAAIhC,KAAJ,CAAUE,GAAG,CAACK,OAAd,CAA3B;AACD;AACF,OAXD;AAYA,aAAOT,EAAE,CAAC,IAAD,EAAO4B,YAAP,CAAT;AACD,KAtCa,CAwCd;;;AACA,QAAIT,MAAJ,EAAY;AACV,aAAOxB,iBAAiB,CAACI,GAAD,EAAMC,EAAN,CAAxB;AACD,KA3Ca,CA6Cd;;;AACA,WAAON,aAAa,CAACK,GAAD,EAAMC,EAAN,CAApB;AACD,GA/CD;AAgDD;;AAED,SAASmC,UAAT,CAAqBC,MAArB,EAA6BC,OAA7B,EAAsCC,QAAtC,EAAgD;AAC9CA,EAAAA,QAAQ,GAAG7C,IAAI,CAAC6C,QAAD,CAAf;AACAD,EAAAA,OAAO,CAACE,EAAR,GAAaF,OAAO,CAACE,EAAR,IAAc,EAA3B;;AAEA,MAAIC,KAAK,CAACC,OAAN,CAAcJ,OAAO,CAACZ,IAAtB,CAAJ,EAAiC;AAC/BY,IAAAA,OAAO,CAACZ,IAAR,GAAeY,OAAO,CAACZ,IAAR,CAAaiB,IAAb,CAAkB,GAAlB,CAAf;AACD;;AACD,MAAIL,OAAO,CAACM,IAAR,IAAgB,CAACH,KAAK,CAACC,OAAN,CAAcJ,OAAO,CAACM,IAAtB,CAArB,EAAkD;AAChDN,IAAAA,OAAO,CAACM,IAAR,GAAe,CAACN,OAAO,CAACM,IAAT,CAAf;AACD;;AACD,MAAIN,OAAO,CAACM,IAAZ,EAAkB;AAChBN,IAAAA,OAAO,CAACE,EAAR,CAAWK,GAAX,GAAiBP,OAAO,CAACM,IAAzB;AACD;;AACD,MAAIN,OAAO,CAACQ,QAAZ,EAAsB;AACpBR,IAAAA,OAAO,CAACE,EAAR,CAAWM,QAAX,GAAsB,IAAtB;AACD;;AAED,MAAIR,OAAO,CAACE,EAAR,CAAWO,CAAf,EAAkB;AAChBT,IAAAA,OAAO,CAACE,EAAR,CAAWQ,SAAX,GAAuBV,OAAO,CAACE,EAAR,CAAWO,CAAlC,CADgB,CAEhB;;AACA,WAAOT,OAAO,CAACE,EAAR,CAAWO,CAAlB;AACD;;AAEDT,EAAAA,OAAO,CAACE,EAAR,CAAW,iBAAX,IAAgC,IAAhC;;AAEA,MAAIF,OAAO,CAACtB,MAAZ,EAAoB;AAClBsB,IAAAA,OAAO,CAACvB,MAAR,GAAiB,KAAjB;AACD,GA3B6C,CA6B9C;;;AACA,SAAOuB,OAAO,CAACE,EAAR,CAAWS,cAAlB;AAEA,QAAM1B,MAAM,GAAG,MAAf;AACA,QAAML,OAAO,GAAGgC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBd,MAAM,CAACnB,OAAzB,CAAhB;;AAEA,MAAI3B,MAAJ,EAAY;AACV;AACA2B,IAAAA,OAAO,CAAC,YAAD,CAAP,GAAwBmB,MAAM,CAAC,YAAD,CAA9B;AACD;;AAED,MAAIC,OAAO,CAACc,SAAZ,EAAuB;AACrB,QAAI,CAACd,OAAO,CAACe,iBAAb,EAAgC;AAC9B,aAAOd,QAAQ,CAAC,IAAIpC,KAAJ,CAAU,sBAAV,CAAD,CAAf;AACD;;AAEDe,IAAAA,OAAO,CAAC,cAAD,CAAP,GAA2B,iCAAgCoB,OAAO,CAACe,iBAAkB,EAArF;AACD;;AAED,QAAMb,EAAE,GAAGrD,EAAE,CAACmE,SAAH,CAAahB,OAAO,CAACE,EAArB,EAAyB;AAClCe,IAAAA,WAAW,EAAE,QADqB;AAElCC,IAAAA,OAAO,EAAEC,IAAI,IAAI;AACf;AACA;AACA;AACA,UAAIC,MAAM,CAACC,QAAP,CAAgBF,IAAhB,CAAJ,EAA2B;AACzB,YAAIG,UAAU,GAAG,EAAjB;;AACA,aAAK,MAAMC,IAAX,IAAmBJ,IAAnB,EAAyB;AACvB;AACA;AACA,cACGI,IAAI,IAAI,IAAR,IAAgBA,IAAI,IAAI,IAAzB,IACCA,IAAI,IAAI,IAAR,IAAgBA,IAAI,IAAI,IADzB,IAECA,IAAI,IAAI,IAAR,IAAgBA,IAAI,IAAI,IAFzB,IAGCA,IAAI,KAAK,IAHV,IAICA,IAAI,KAAK,IAJV,IAKCA,IAAI,KAAK,IALV,IAMCA,IAAI,KAAK,IAPZ,EAQE;AACAD,YAAAA,UAAU,IAAIE,MAAM,CAACC,YAAP,CAAoBF,IAApB,CAAd;AACD,WAVD,MAUO;AACL,kBAAMG,GAAG,GAAGH,IAAI,CAAClD,QAAL,CAAc,EAAd,CAAZ,CADK,CAEL;;AACA,kBAAMsD,MAAM,GAAGD,GAAG,CAACE,MAAJ,KAAe,CAAf,GAAoB,IAAGF,GAAI,EAA3B,GAA+BA,GAA9C;AACAJ,YAAAA,UAAU,IAAK,IAAGK,MAAO,EAAzB;AACD;AACF;;AACD,eAAOL,UAAP;AACD;;AACD,aAAOvE,gBAAgB,CAACoE,IAAD,CAAvB;AACD;AA/BiC,GAAzB,CAAX;AAiCA,QAAMU,UAAU,GAAG;AACjBC,IAAAA,QAAQ,EAAE/B,MAAM,CAACZ,IADA;AAEjBC,IAAAA,IAAI,EAAG,GAAEW,MAAM,CAAC,UAAD,CAAa,GAAEC,OAAO,CAACZ,IAAK,IAAGc,EAAG,EAFhC;AAGjB6B,IAAAA,IAAI,EAAEhC,MAAM,CAACgC,IAHI;AAIjB9C,IAAAA,MAAM,EAAEA,MAJS;AAKjBL,IAAAA,OAAO,EAAEA,OALQ;AAMjBoD,IAAAA,QAAQ,EAAG,GAAEjC,MAAM,CAACiC,QAAS;AANZ,GAAnB;AASA,QAAMhD,GAAG,GAAGzB,OAAO,CAACwC,MAAM,CAACiC,QAAR,CAAP,CAAyBH,UAAzB,EAAqCrD,KAAK,CAACwB,OAAO,CAACvB,MAAT,EAAiBwB,QAAjB,CAA1C,CAAZ;AAEAjB,EAAAA,GAAG,CAACS,EAAJ,CAAO,OAAP,EAAiB1B,GAAD,IAAS;AACvBkC,IAAAA,QAAQ,CAAClC,GAAD,CAAR;AACD,GAFD;;AAIA,MAAI,CAACiC,OAAO,CAACtB,MAAb,EAAqB;AACnBM,IAAAA,GAAG,CAACiD,GAAJ;AACD;;AAED,SAAOjD,GAAP;AACD,C,CAED;AACA;;;AAEAkD,OAAO,GAAGC,MAAM,CAACD,OAAP,GAAkBnC,MAAD,IAAY;AACrC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,QAAMqC,IAAI,GAAG,CAACpC,OAAD,EAAUC,QAAV,KAAuB;AAClC,QAAI,OAAOD,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,aAAOC,QAAQ,CAAC,IAAIpC,KAAJ,CAAU,wBAAV,CAAD,CAAf;AACD;;AAED,WAAOiC,UAAU,CAACC,MAAD,EAASC,OAAT,EAAkBC,QAAlB,CAAjB;AACD,GAND,CAVqC,CAkBrC;AACA;AACA;AACA;;;AACAmC,EAAAA,IAAI,CAACC,YAAL,GAAoB,CAACrC,OAAD,EAAUsC,SAAV,EAAqBrC,QAArB,KAAkC;AACpD,WAAOmC,IAAI,CAACpC,OAAD,EAAU,CAACjC,GAAD,EAAML,GAAN,KAAc;AACjC,UAAIK,GAAJ,EAAS;AACP,eAAOkC,QAAQ,CAAClC,GAAD,CAAf;AACD;;AACDuE,MAAAA,SAAS,CAAC5E,GAAD,EAAMuC,QAAN,CAAT;AACD,KALU,CAAX;AAMD,GAPD;;AASA,SAAOmC,IAAP;AACD,CAhCD","sourcesContent":["'use strict'\n\nconst Qs = require('qs')\nconst qsDefaultEncoder = require('qs/lib/utils').encode\nconst isNode = require('detect-node')\nconst ndjson = require('ndjson')\nconst pump = require('pump')\nconst once = require('once')\nconst streamToValue = require('./stream-to-value')\nconst streamToJsonValue = require('./stream-to-json-value')\nconst request = require('./request')\nconst log = require('debug')('ipfs-api:request')\n\n// -- Internal\n\nfunction parseError (res, cb) {\n  const error = new Error(`Server responded with ${res.statusCode}`)\n\n  streamToJsonValue(res, (err, payload) => {\n    if (err) {\n      return cb(err)\n    }\n\n    if (payload) {\n      error.code = payload.Code\n      error.message = payload.Message || payload.toString()\n      error.type = payload.Type\n    }\n    cb(error)\n  })\n}\n\nfunction onRes (buffer, cb) {\n  return (res) => {\n    const stream = Boolean(res.headers['x-stream-output'])\n    const chunkedObjects = Boolean(res.headers['x-chunked-output'])\n    const isJson = res.headers['content-type'] &&\n                   res.headers['content-type'].indexOf('application/json') === 0\n\n    if (res.req) {\n      log(res.req.method, `${res.req.getHeaders().host}${res.req.path}`, res.statusCode, res.statusMessage)\n    } else {\n      log(res.url, res.statusCode, res.statusMessage)\n    }\n\n    if (res.statusCode >= 400 || !res.statusCode) {\n      return parseError(res, cb)\n    }\n\n    // Return the response stream directly\n    if (stream && !buffer) {\n      return cb(null, res)\n    }\n\n    // Return a stream of JSON objects\n    if (chunkedObjects && isJson) {\n      const outputStream = ndjson.parse()\n      pump(res, outputStream)\n      res.on('end', () => {\n        let err = res.trailers['x-stream-error']\n        if (err) {\n          // Not all errors are JSON\n          try {\n            err = JSON.parse(err)\n          } catch (e) {\n            err = { Message: err }\n          }\n          outputStream.emit('error', new Error(err.Message))\n        }\n      })\n      return cb(null, outputStream)\n    }\n\n    // Return a JSON object\n    if (isJson) {\n      return streamToJsonValue(res, cb)\n    }\n\n    // Return a value\n    return streamToValue(res, cb)\n  }\n}\n\nfunction requestAPI (config, options, callback) {\n  callback = once(callback)\n  options.qs = options.qs || {}\n\n  if (Array.isArray(options.path)) {\n    options.path = options.path.join('/')\n  }\n  if (options.args && !Array.isArray(options.args)) {\n    options.args = [options.args]\n  }\n  if (options.args) {\n    options.qs.arg = options.args\n  }\n  if (options.progress) {\n    options.qs.progress = true\n  }\n\n  if (options.qs.r) {\n    options.qs.recursive = options.qs.r\n    // From IPFS 0.4.0, it throws an error when both r and recursive are passed\n    delete options.qs.r\n  }\n\n  options.qs['stream-channels'] = true\n\n  if (options.stream) {\n    options.buffer = false\n  }\n\n  // this option is only used internally, not passed to daemon\n  delete options.qs.followSymlinks\n\n  const method = 'POST'\n  const headers = Object.assign({}, config.headers)\n\n  if (isNode) {\n    // Browsers do not allow you to modify the user agent\n    headers['User-Agent'] = config['user-agent']\n  }\n\n  if (options.multipart) {\n    if (!options.multipartBoundary) {\n      return callback(new Error('No multipartBoundary'))\n    }\n\n    headers['Content-Type'] = `multipart/form-data; boundary=${options.multipartBoundary}`\n  }\n\n  const qs = Qs.stringify(options.qs, {\n    arrayFormat: 'repeat',\n    encoder: data => {\n      // TODO: future releases of qs will provide the default\n      // encoder as a 2nd argument to this function; it will\n      // no longer be necessary to import qsDefaultEncoder\n      if (Buffer.isBuffer(data)) {\n        let uriEncoded = ''\n        for (const byte of data) {\n          // https://tools.ietf.org/html/rfc3986#page-14\n          // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E)\n          if (\n            (byte >= 0x41 && byte <= 0x5A) ||\n            (byte >= 0x61 && byte <= 0x7A) ||\n            (byte >= 0x30 && byte <= 0x39) ||\n            (byte === 0x2D) ||\n            (byte === 0x2E) ||\n            (byte === 0x5F) ||\n            (byte === 0x7E)\n          ) {\n            uriEncoded += String.fromCharCode(byte)\n          } else {\n            const hex = byte.toString(16)\n            // String.prototype.padStart() not widely supported yet\n            const padded = hex.length === 1 ? `0${hex}` : hex\n            uriEncoded += `%${padded}`\n          }\n        }\n        return uriEncoded\n      }\n      return qsDefaultEncoder(data)\n    }\n  })\n  const reqOptions = {\n    hostname: config.host,\n    path: `${config['api-path']}${options.path}?${qs}`,\n    port: config.port,\n    method: method,\n    headers: headers,\n    protocol: `${config.protocol}:`\n  }\n\n  const req = request(config.protocol)(reqOptions, onRes(options.buffer, callback))\n\n  req.on('error', (err) => {\n    callback(err)\n  })\n\n  if (!options.stream) {\n    req.end()\n  }\n\n  return req\n}\n\n//\n// -- Module Interface\n\nexports = module.exports = (config) => {\n  /*\n   * options: {\n   *   path:   // API path (like /add or /config) - type: string\n   *   args:   // Arguments to the command - type: object\n   *   qs:     // Opts as query string opts to the command --something - type: object\n   *   files:  // files to be sent - type: string, buffer or array of strings or buffers\n   *   buffer: // buffer the request before sending it - type: bool\n   * }\n   */\n  const send = (options, callback) => {\n    if (typeof options !== 'object') {\n      return callback(new Error('no options were passed'))\n    }\n\n    return requestAPI(config, options, callback)\n  }\n\n  // Send a HTTP request and pass via a transform function\n  // to convert the response data to wanted format before\n  // returning it to the callback.\n  // Eg. send.andTransform({}, (e) => JSON.parse(e), (err, res) => ...)\n  send.andTransform = (options, transform, callback) => {\n    return send(options, (err, res) => {\n      if (err) {\n        return callback(err)\n      }\n      transform(res, callback)\n    })\n  }\n\n  return send\n}\n"]},"metadata":{},"sourceType":"script"}