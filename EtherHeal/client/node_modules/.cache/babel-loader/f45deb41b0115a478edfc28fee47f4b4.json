{"ast":null,"code":"'use strict';\n\nconst bs58 = require('bs58');\n\nconst multihashing = require('multihashing-async');\n\nmodule.exports = (keysProtobuf, randomBytes, crypto) => {\n  crypto = crypto || require('./crypto')(randomBytes);\n\n  class Secp256k1PublicKey {\n    constructor(key) {\n      crypto.validatePublicKey(key);\n      this._key = key;\n    }\n\n    verify(data, sig, callback) {\n      ensure(callback);\n      crypto.hashAndVerify(this._key, sig, data, callback);\n    }\n\n    marshal() {\n      return crypto.compressPublicKey(this._key);\n    }\n\n    get bytes() {\n      return keysProtobuf.PublicKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      });\n    }\n\n    equals(key) {\n      return this.bytes.equals(key.bytes);\n    }\n\n    hash(callback) {\n      ensure(callback);\n      multihashing(this.bytes, 'sha2-256', callback);\n    }\n\n  }\n\n  class Secp256k1PrivateKey {\n    constructor(key, publicKey) {\n      this._key = key;\n      this._publicKey = publicKey || crypto.computePublicKey(key);\n      crypto.validatePrivateKey(this._key);\n      crypto.validatePublicKey(this._publicKey);\n    }\n\n    sign(message, callback) {\n      ensure(callback);\n      crypto.hashAndSign(this._key, message, callback);\n    }\n\n    get public() {\n      return new Secp256k1PublicKey(this._publicKey);\n    }\n\n    marshal() {\n      return this._key;\n    }\n\n    get bytes() {\n      return keysProtobuf.PrivateKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      });\n    }\n\n    equals(key) {\n      return this.bytes.equals(key.bytes);\n    }\n\n    hash(callback) {\n      ensure(callback);\n      multihashing(this.bytes, 'sha2-256', callback);\n    }\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @param {function(Error, id)} callback\n     * @returns {undefined}\n     */\n\n\n    id(callback) {\n      this.public.hash((err, hash) => {\n        if (err) {\n          return callback(err);\n        }\n\n        callback(null, bs58.encode(hash));\n      });\n    }\n\n  }\n\n  function unmarshalSecp256k1PrivateKey(bytes, callback) {\n    callback(null, new Secp256k1PrivateKey(bytes));\n  }\n\n  function unmarshalSecp256k1PublicKey(bytes) {\n    return new Secp256k1PublicKey(bytes);\n  }\n\n  function generateKeyPair(_bits, callback) {\n    if (callback === undefined && typeof _bits === 'function') {\n      callback = _bits;\n    }\n\n    ensure(callback);\n    crypto.generateKey((err, privateKeyBytes) => {\n      if (err) {\n        return callback(err);\n      }\n\n      let privkey;\n\n      try {\n        privkey = new Secp256k1PrivateKey(privateKeyBytes);\n      } catch (err) {\n        return callback(err);\n      }\n\n      callback(null, privkey);\n    });\n  }\n\n  function ensure(callback) {\n    if (typeof callback !== 'function') {\n      throw new Error('callback is required');\n    }\n  }\n\n  return {\n    Secp256k1PublicKey,\n    Secp256k1PrivateKey,\n    unmarshalSecp256k1PrivateKey,\n    unmarshalSecp256k1PublicKey,\n    generateKeyPair\n  };\n};","map":{"version":3,"sources":["Z:/Projects/Rakuten Hack/EtherealHeal/Complete Project/client/node_modules/peer-id/node_modules/libp2p-crypto-secp256k1/src/index.js"],"names":["bs58","require","multihashing","module","exports","keysProtobuf","randomBytes","crypto","Secp256k1PublicKey","constructor","key","validatePublicKey","_key","verify","data","sig","callback","ensure","hashAndVerify","marshal","compressPublicKey","bytes","PublicKey","encode","Type","KeyType","Secp256k1","Data","equals","hash","Secp256k1PrivateKey","publicKey","_publicKey","computePublicKey","validatePrivateKey","sign","message","hashAndSign","public","PrivateKey","id","err","unmarshalSecp256k1PrivateKey","unmarshalSecp256k1PublicKey","generateKeyPair","_bits","undefined","generateKey","privateKeyBytes","privkey","Error"],"mappings":"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","sourcesContent":["'use strict'\n\nconst bs58 = require('bs58')\nconst multihashing = require('multihashing-async')\n\nmodule.exports = (keysProtobuf, randomBytes, crypto) => {\n  crypto = crypto || require('./crypto')(randomBytes)\n\n  class Secp256k1PublicKey {\n    constructor (key) {\n      crypto.validatePublicKey(key)\n      this._key = key\n    }\n\n    verify (data, sig, callback) {\n      ensure(callback)\n      crypto.hashAndVerify(this._key, sig, data, callback)\n    }\n\n    marshal () {\n      return crypto.compressPublicKey(this._key)\n    }\n\n    get bytes () {\n      return keysProtobuf.PublicKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      })\n    }\n\n    equals (key) {\n      return this.bytes.equals(key.bytes)\n    }\n\n    hash (callback) {\n      ensure(callback)\n      multihashing(this.bytes, 'sha2-256', callback)\n    }\n  }\n\n  class Secp256k1PrivateKey {\n    constructor (key, publicKey) {\n      this._key = key\n      this._publicKey = publicKey || crypto.computePublicKey(key)\n      crypto.validatePrivateKey(this._key)\n      crypto.validatePublicKey(this._publicKey)\n    }\n\n    sign (message, callback) {\n      ensure(callback)\n      crypto.hashAndSign(this._key, message, callback)\n    }\n\n    get public () {\n      return new Secp256k1PublicKey(this._publicKey)\n    }\n\n    marshal () {\n      return this._key\n    }\n\n    get bytes () {\n      return keysProtobuf.PrivateKey.encode({\n        Type: keysProtobuf.KeyType.Secp256k1,\n        Data: this.marshal()\n      })\n    }\n\n    equals (key) {\n      return this.bytes.equals(key.bytes)\n    }\n\n    hash (callback) {\n      ensure(callback)\n      multihashing(this.bytes, 'sha2-256', callback)\n    }\n\n    /**\n     * Gets the ID of the key.\n     *\n     * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n     * The public key is a protobuf encoding containing a type and the DER encoding\n     * of the PKCS SubjectPublicKeyInfo.\n     *\n     * @param {function(Error, id)} callback\n     * @returns {undefined}\n     */\n    id (callback) {\n      this.public.hash((err, hash) => {\n        if (err) {\n          return callback(err)\n        }\n        callback(null, bs58.encode(hash))\n      })\n    }\n  }\n\n  function unmarshalSecp256k1PrivateKey (bytes, callback) {\n    callback(null, new Secp256k1PrivateKey(bytes))\n  }\n\n  function unmarshalSecp256k1PublicKey (bytes) {\n    return new Secp256k1PublicKey(bytes)\n  }\n\n  function generateKeyPair (_bits, callback) {\n    if (callback === undefined && typeof _bits === 'function') {\n      callback = _bits\n    }\n\n    ensure(callback)\n\n    crypto.generateKey((err, privateKeyBytes) => {\n      if (err) { return callback(err) }\n\n      let privkey\n      try {\n        privkey = new Secp256k1PrivateKey(privateKeyBytes)\n      } catch (err) { return callback(err) }\n\n      callback(null, privkey)\n    })\n  }\n\n  function ensure (callback) {\n    if (typeof callback !== 'function') {\n      throw new Error('callback is required')\n    }\n  }\n\n  return {\n    Secp256k1PublicKey,\n    Secp256k1PrivateKey,\n    unmarshalSecp256k1PrivateKey,\n    unmarshalSecp256k1PublicKey,\n    generateKeyPair\n  }\n}\n"]},"metadata":{},"sourceType":"script"}