{"ast":null,"code":"'use strict';\n\nconst promisify = require('promisify-es6');\n\nconst EventEmitter = require('events');\n\nconst eos = require('end-of-stream');\n\nconst isNode = require('detect-node');\n\nconst setImmediate = require('async/setImmediate');\n\nconst PubsubMessageStream = require('./utils/pubsub-message-stream');\n\nconst stringlistToArray = require('./utils/stringlist-to-array');\n\nconst moduleConfig = require('./utils/module-config');\n\nconst NotSupportedError = () => new Error('pubsub is currently not supported when run in the browser');\n/* Public API */\n\n\nmodule.exports = arg => {\n  const send = moduleConfig(arg);\n  /* Internal subscriptions state and functions */\n\n  const ps = new EventEmitter();\n  const subscriptions = {};\n  ps.id = Math.random();\n  return {\n    subscribe: (topic, handler, options, callback) => {\n      const defaultOptions = {\n        discover: false\n      };\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = defaultOptions;\n      }\n\n      if (!options) {\n        options = defaultOptions;\n      } // Throw an error if ran in the browsers\n\n\n      if (!isNode) {\n        if (!callback) {\n          return Promise.reject(NotSupportedError());\n        }\n\n        return setImmediate(() => callback(NotSupportedError()));\n      } // promisify doesn't work as we always pass a\n      // function as last argument (`handler`)\n\n\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          subscribe(topic, handler, options, err => {\n            if (err) {\n              return reject(err);\n            }\n\n            resolve();\n          });\n        });\n      }\n\n      subscribe(topic, handler, options, callback);\n    },\n    unsubscribe: (topic, handler, callback) => {\n      if (!isNode) {\n        if (!callback) {\n          return Promise.reject(NotSupportedError());\n        }\n\n        return setImmediate(() => callback(NotSupportedError()));\n      }\n\n      if (ps.listenerCount(topic) === 0 || !subscriptions[topic]) {\n        const err = new Error(`Not subscribed to '${topic}'`);\n\n        if (!callback) {\n          return Promise.reject(err);\n        }\n\n        return setImmediate(() => callback(err));\n      }\n\n      ps.removeListener(topic, handler); // Drop the request once we are actually done\n\n      if (ps.listenerCount(topic) === 0) {\n        if (!callback) {\n          return new Promise((resolve, reject) => {\n            // When the response stream has ended, resolve the promise\n            eos(subscriptions[topic].res, err => {\n              // FIXME: Artificial timeout needed to ensure unsubscribed\n              setTimeout(() => {\n                if (err) return reject(err);\n                resolve();\n              });\n            });\n            subscriptions[topic].req.abort();\n            subscriptions[topic] = null;\n          });\n        } // When the response stream has ended, call the callback\n\n\n        eos(subscriptions[topic].res, err => {\n          // FIXME: Artificial timeout needed to ensure unsubscribed\n          setTimeout(() => callback(err));\n        });\n        subscriptions[topic].req.abort();\n        subscriptions[topic] = null;\n        return;\n      }\n\n      if (!callback) {\n        return Promise.resolve();\n      }\n\n      setImmediate(() => callback());\n    },\n    publish: promisify((topic, data, callback) => {\n      if (!isNode) {\n        return callback(NotSupportedError());\n      }\n\n      if (!Buffer.isBuffer(data)) {\n        return callback(new Error('data must be a Buffer'));\n      }\n\n      const request = {\n        path: 'pubsub/pub',\n        args: [topic, data]\n      };\n      send(request, callback);\n    }),\n    ls: promisify(callback => {\n      if (!isNode) {\n        return callback(NotSupportedError());\n      }\n\n      const request = {\n        path: 'pubsub/ls'\n      };\n      send.andTransform(request, stringlistToArray, callback);\n    }),\n    peers: promisify((topic, callback) => {\n      if (!isNode) {\n        return callback(NotSupportedError());\n      }\n\n      const request = {\n        path: 'pubsub/peers',\n        args: [topic]\n      };\n      send.andTransform(request, stringlistToArray, callback);\n    }),\n\n    setMaxListeners(n) {\n      return ps.setMaxListeners(n);\n    }\n\n  };\n\n  function subscribe(topic, handler, options, callback) {\n    ps.on(topic, handler);\n\n    if (subscriptions[topic]) {\n      // TODO: should a callback error be returned?\n      return callback();\n    } // Request params\n\n\n    const request = {\n      path: 'pubsub/sub',\n      args: [topic],\n      qs: {\n        discover: options.discover\n      }\n    }; // Start the request and transform the response\n    // stream to Pubsub messages stream\n\n    subscriptions[topic] = {};\n    subscriptions[topic].req = send.andTransform(request, PubsubMessageStream.from, (err, stream) => {\n      if (err) {\n        subscriptions[topic] = null;\n        ps.removeListener(topic, handler);\n        return callback(err);\n      }\n\n      subscriptions[topic].res = stream;\n      stream.on('data', msg => {\n        ps.emit(topic, msg);\n      });\n      stream.on('error', err => {\n        ps.emit('error', err);\n      });\n      eos(stream, err => {\n        if (err) {\n          ps.emit('error', err);\n        }\n\n        subscriptions[topic] = null;\n        ps.removeListener(topic, handler);\n      });\n      callback();\n    });\n  }\n};","map":{"version":3,"sources":["z:/Projects/EtherealOrgan-copy/Complete Project/client/node_modules/ipfs-api/src/pubsub.js"],"names":["promisify","require","EventEmitter","eos","isNode","setImmediate","PubsubMessageStream","stringlistToArray","moduleConfig","NotSupportedError","Error","module","exports","arg","send","ps","subscriptions","id","Math","random","subscribe","topic","handler","options","callback","defaultOptions","discover","Promise","reject","resolve","err","unsubscribe","listenerCount","removeListener","res","setTimeout","req","abort","publish","data","Buffer","isBuffer","request","path","args","ls","andTransform","peers","setMaxListeners","n","on","qs","from","stream","msg","emit"],"mappings":"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","sourcesContent":["'use strict'\n\nconst promisify = require('promisify-es6')\nconst EventEmitter = require('events')\nconst eos = require('end-of-stream')\nconst isNode = require('detect-node')\nconst setImmediate = require('async/setImmediate')\nconst PubsubMessageStream = require('./utils/pubsub-message-stream')\nconst stringlistToArray = require('./utils/stringlist-to-array')\nconst moduleConfig = require('./utils/module-config')\n\nconst NotSupportedError = () => new Error('pubsub is currently not supported when run in the browser')\n\n/* Public API */\nmodule.exports = (arg) => {\n  const send = moduleConfig(arg)\n\n  /* Internal subscriptions state and functions */\n  const ps = new EventEmitter()\n  const subscriptions = {}\n  ps.id = Math.random()\n  return {\n    subscribe: (topic, handler, options, callback) => {\n      const defaultOptions = {\n        discover: false\n      }\n\n      if (typeof options === 'function') {\n        callback = options\n        options = defaultOptions\n      }\n\n      if (!options) {\n        options = defaultOptions\n      }\n\n      // Throw an error if ran in the browsers\n      if (!isNode) {\n        if (!callback) {\n          return Promise.reject(NotSupportedError())\n        }\n\n        return setImmediate(() => callback(NotSupportedError()))\n      }\n\n      // promisify doesn't work as we always pass a\n      // function as last argument (`handler`)\n      if (!callback) {\n        return new Promise((resolve, reject) => {\n          subscribe(topic, handler, options, (err) => {\n            if (err) {\n              return reject(err)\n            }\n            resolve()\n          })\n        })\n      }\n\n      subscribe(topic, handler, options, callback)\n    },\n    unsubscribe: (topic, handler, callback) => {\n      if (!isNode) {\n        if (!callback) {\n          return Promise.reject(NotSupportedError())\n        }\n\n        return setImmediate(() => callback(NotSupportedError()))\n      }\n\n      if (ps.listenerCount(topic) === 0 || !subscriptions[topic]) {\n        const err = new Error(`Not subscribed to '${topic}'`)\n\n        if (!callback) {\n          return Promise.reject(err)\n        }\n\n        return setImmediate(() => callback(err))\n      }\n\n      ps.removeListener(topic, handler)\n\n      // Drop the request once we are actually done\n      if (ps.listenerCount(topic) === 0) {\n        if (!callback) {\n          return new Promise((resolve, reject) => {\n            // When the response stream has ended, resolve the promise\n            eos(subscriptions[topic].res, (err) => {\n              // FIXME: Artificial timeout needed to ensure unsubscribed\n              setTimeout(() => {\n                if (err) return reject(err)\n                resolve()\n              })\n            })\n            subscriptions[topic].req.abort()\n            subscriptions[topic] = null\n          })\n        }\n\n        // When the response stream has ended, call the callback\n        eos(subscriptions[topic].res, (err) => {\n          // FIXME: Artificial timeout needed to ensure unsubscribed\n          setTimeout(() => callback(err))\n        })\n        subscriptions[topic].req.abort()\n        subscriptions[topic] = null\n        return\n      }\n\n      if (!callback) {\n        return Promise.resolve()\n      }\n\n      setImmediate(() => callback())\n    },\n    publish: promisify((topic, data, callback) => {\n      if (!isNode) {\n        return callback(NotSupportedError())\n      }\n\n      if (!Buffer.isBuffer(data)) {\n        return callback(new Error('data must be a Buffer'))\n      }\n\n      const request = {\n        path: 'pubsub/pub',\n        args: [topic, data]\n      }\n\n      send(request, callback)\n    }),\n    ls: promisify((callback) => {\n      if (!isNode) {\n        return callback(NotSupportedError())\n      }\n\n      const request = {\n        path: 'pubsub/ls'\n      }\n\n      send.andTransform(request, stringlistToArray, callback)\n    }),\n    peers: promisify((topic, callback) => {\n      if (!isNode) {\n        return callback(NotSupportedError())\n      }\n\n      const request = {\n        path: 'pubsub/peers',\n        args: [topic]\n      }\n\n      send.andTransform(request, stringlistToArray, callback)\n    }),\n    setMaxListeners (n) {\n      return ps.setMaxListeners(n)\n    }\n  }\n\n  function subscribe (topic, handler, options, callback) {\n    ps.on(topic, handler)\n\n    if (subscriptions[topic]) {\n      // TODO: should a callback error be returned?\n      return callback()\n    }\n\n    // Request params\n    const request = {\n      path: 'pubsub/sub',\n      args: [topic],\n      qs: {\n        discover: options.discover\n      }\n    }\n\n    // Start the request and transform the response\n    // stream to Pubsub messages stream\n    subscriptions[topic] = {}\n    subscriptions[topic].req = send.andTransform(request, PubsubMessageStream.from, (err, stream) => {\n      if (err) {\n        subscriptions[topic] = null\n        ps.removeListener(topic, handler)\n        return callback(err)\n      }\n\n      subscriptions[topic].res = stream\n\n      stream.on('data', (msg) => {\n        ps.emit(topic, msg)\n      })\n\n      stream.on('error', (err) => {\n        ps.emit('error', err)\n      })\n\n      eos(stream, (err) => {\n        if (err) {\n          ps.emit('error', err)\n        }\n\n        subscriptions[topic] = null\n        ps.removeListener(topic, handler)\n      })\n\n      callback()\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}