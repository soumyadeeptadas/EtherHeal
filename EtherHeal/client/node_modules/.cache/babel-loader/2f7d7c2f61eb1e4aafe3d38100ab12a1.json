{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nconst mh = require('multihashes');\n\nconst cryptoKeys = require('libp2p-crypto/src/keys');\n\nconst assert = require('assert');\n\nconst waterfall = require('async/waterfall');\n\nconst withIs = require('class-is');\n\nclass PeerId {\n  constructor(id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided');\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = mh.toB58String(this.id);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  get id() {\n    return this._id;\n  }\n\n  set id(val) {\n    throw new Error('Id is immutable');\n  }\n\n  get privKey() {\n    return this._privKey;\n  }\n\n  set privKey(privKey) {\n    this._privKey = privKey;\n  }\n\n  get pubKey() {\n    if (this._pubKey) {\n      return this._pubKey;\n    }\n\n    if (this._privKey) {\n      return this._privKey.public;\n    }\n\n    const decoded = mh.decode(this.id);\n\n    if (decoded.name === 'identity') {\n      this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);\n      return this._pubKey;\n    }\n  }\n\n  set pubKey(pubKey) {\n    this._pubKey = pubKey;\n  } // Return the protobuf version of the public key, matching go ipfs formatting\n\n\n  marshalPubKey() {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey);\n    }\n  } // Return the protobuf version of the private key, matching go ipfs formatting\n\n\n  marshalPrivKey() {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey);\n    }\n  }\n\n  toPrint() {\n    let pid = this.toB58String(); // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2);\n    }\n\n    let maxRunes = 6;\n\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length;\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>';\n  } // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n\n\n  toJSON() {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    };\n  } // encode/decode functions\n\n\n  toHexString() {\n    return mh.toHexString(this.id);\n  }\n\n  toBytes() {\n    return this.id;\n  }\n\n  toB58String() {\n    return this._idB58String;\n  }\n\n  isEqual(id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id);\n    } else if (id.id) {\n      return this.id.equals(id.id);\n    } else {\n      throw new Error('not valid Id');\n    }\n  }\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n\n\n  isValid(callback) {\n    // TODO Needs better checking\n    if (this.privKey && this.privKey.public && this.privKey.public.bytes && Buffer.isBuffer(this.pubKey.bytes) && this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback();\n    } else {\n      callback(new Error('Keys not match'));\n    }\n  }\n\n}\n\nconst PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n});\nexports = module.exports = PeerIdWithIs;\n\nconst computeDigest = (pubKey, cb) => {\n  if (pubKey.bytes.length <= 42) {\n    const digest = mh.encode(pubKey.bytes, 'identity');\n    cb(null, digest);\n  } else {\n    pubKey.hash((err, digest) => {\n      cb(err, digest);\n    });\n  }\n};\n\nconst computePeerId = (privKey, pubKey, cb) => {\n  computeDigest(pubKey, (err, digest) => {\n    if (err != null) {\n      cb(err);\n    } else {\n      cb(null, new PeerIdWithIs(digest, privKey, pubKey));\n    }\n  });\n}; // generation\n\n\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n  opts.bits = opts.bits || 2048;\n  opts.keyType = opts.keyType || 'RSA';\n  cryptoKeys.generateKeyPair(opts.keyType, opts.bits, (err, privKey) => {\n    if (err != null) {\n      callback(err);\n    } else {\n      computePeerId(privKey, privKey.public, callback);\n    }\n  });\n};\n\nexports.createFromHexString = function (str) {\n  return new PeerIdWithIs(mh.fromHexString(str));\n};\n\nexports.createFromBytes = function (buf) {\n  return new PeerIdWithIs(buf);\n};\n\nexports.createFromB58String = function (str) {\n  return new PeerIdWithIs(mh.fromB58String(str));\n}; // Public Key input will be a buffer\n\n\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let pubKey;\n\n  try {\n    let buf = key;\n\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n    pubKey = cryptoKeys.unmarshalPublicKey(buf);\n  } catch (err) {\n    return callback(err);\n  }\n\n  computePeerId(null, pubKey, callback);\n}; // Private key input will be a string\n\n\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let buf = key;\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64');\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer');\n  } catch (err) {\n    return callback(err);\n  }\n\n  cryptoKeys.unmarshalPrivateKey(buf, (err, privKey) => {\n    if (err != null) {\n      callback(err);\n    } else {\n      computePeerId(privKey, privKey.public, callback);\n    }\n  });\n};\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required');\n  }\n\n  let id;\n  let rawPrivKey;\n  let rawPubKey;\n  let pub;\n\n  try {\n    id = mh.fromB58String(obj.id);\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64');\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64');\n    pub = rawPubKey && cryptoKeys.unmarshalPublicKey(rawPubKey);\n  } catch (err) {\n    return callback(err);\n  }\n\n  if (!rawPrivKey) {\n    callback(null, new PeerIdWithIs(id, null, pub));\n    return;\n  }\n\n  waterfall([cb => cryptoKeys.unmarshalPrivateKey(rawPrivKey, cb), (priv, cb) => {\n    computeDigest(priv.public, (err, digest) => {\n      cb(err, digest, priv);\n    });\n  }, (privDigest, priv, cb) => {\n    if (pub) {\n      computeDigest(pub, (err, pubDigest) => {\n        cb(err, privDigest, priv, pubDigest);\n      });\n    } else {\n      cb(null, privDigest, priv);\n    }\n  }], (err, privDigest, priv, pubDigest) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (pub && !privDigest.equals(pubDigest)) {\n      return callback(new Error('Public and private key do not match'));\n    }\n\n    if (id && !privDigest.equals(id)) {\n      return callback(new Error('Id and private key do not match'));\n    }\n\n    callback(null, new PeerIdWithIs(id, priv, pub));\n  });\n};\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return val.toString('base64');\n  }\n}","map":{"version":3,"sources":["z:/Projects/EtherealOrgan-copy/Complete Project/client/node_modules/peer-id/src/index.js"],"names":["mh","require","cryptoKeys","assert","waterfall","withIs","PeerId","constructor","id","privKey","pubKey","Buffer","isBuffer","public","bytes","equals","_id","_idB58String","toB58String","_privKey","_pubKey","val","Error","decoded","decode","name","unmarshalPublicKey","digest","marshalPubKey","marshalPublicKey","marshalPrivKey","marshalPrivateKey","toPrint","pid","startsWith","slice","maxRunes","length","substr","toJSON","toB64Opt","toHexString","toBytes","isEqual","isValid","callback","PeerIdWithIs","className","symbolName","exports","module","computeDigest","cb","encode","hash","err","computePeerId","create","opts","bits","keyType","generateKeyPair","createFromHexString","str","fromHexString","createFromBytes","buf","createFromB58String","fromB58String","createFromPubKey","key","from","createFromPrivKey","unmarshalPrivateKey","createFromJSON","obj","rawPrivKey","rawPubKey","pub","priv","privDigest","pubDigest","isPeerId","peerId","Boolean","toString"],"mappings":"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","sourcesContent":["/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n\n'use strict'\n\nconst mh = require('multihashes')\nconst cryptoKeys = require('libp2p-crypto/src/keys')\nconst assert = require('assert')\nconst waterfall = require('async/waterfall')\nconst withIs = require('class-is')\n\nclass PeerId {\n  constructor (id, privKey, pubKey) {\n    assert(Buffer.isBuffer(id), 'invalid id provided')\n\n    if (privKey && pubKey) {\n      assert(privKey.public.bytes.equals(pubKey.bytes), 'inconsistent arguments')\n    }\n\n    this._id = id\n    this._idB58String = mh.toB58String(this.id)\n    this._privKey = privKey\n    this._pubKey = pubKey\n  }\n\n  get id () {\n    return this._id\n  }\n\n  set id (val) {\n    throw new Error('Id is immutable')\n  }\n\n  get privKey () {\n    return this._privKey\n  }\n\n  set privKey (privKey) {\n    this._privKey = privKey\n  }\n\n  get pubKey () {\n    if (this._pubKey) {\n      return this._pubKey\n    }\n\n    if (this._privKey) {\n      return this._privKey.public\n    }\n\n    const decoded = mh.decode(this.id)\n\n    if (decoded.name === 'identity') {\n      this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest)\n      return this._pubKey\n    }\n  }\n\n  set pubKey (pubKey) {\n    this._pubKey = pubKey\n  }\n\n  // Return the protobuf version of the public key, matching go ipfs formatting\n  marshalPubKey () {\n    if (this.pubKey) {\n      return cryptoKeys.marshalPublicKey(this.pubKey)\n    }\n  }\n\n  // Return the protobuf version of the private key, matching go ipfs formatting\n  marshalPrivKey () {\n    if (this.privKey) {\n      return cryptoKeys.marshalPrivateKey(this.privKey)\n    }\n  }\n\n  toPrint () {\n    let pid = this.toB58String()\n    // All sha256 nodes start with Qm\n    // We can skip the Qm to make the peer.ID more useful\n    if (pid.startsWith('Qm')) {\n      pid = pid.slice(2)\n    }\n    let maxRunes = 6\n    if (pid.length < maxRunes) {\n      maxRunes = pid.length\n    }\n\n    return '<peer.ID ' + pid.substr(0, maxRunes) + '>'\n  }\n\n  // return the jsonified version of the key, matching the formatting\n  // of go-ipfs for its config file\n  toJSON () {\n    return {\n      id: this.toB58String(),\n      privKey: toB64Opt(this.marshalPrivKey()),\n      pubKey: toB64Opt(this.marshalPubKey())\n    }\n  }\n\n  // encode/decode functions\n  toHexString () {\n    return mh.toHexString(this.id)\n  }\n\n  toBytes () {\n    return this.id\n  }\n\n  toB58String () {\n    return this._idB58String\n  }\n\n  isEqual (id) {\n    if (Buffer.isBuffer(id)) {\n      return this.id.equals(id)\n    } else if (id.id) {\n      return this.id.equals(id.id)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /*\n   * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n   */\n  isValid (callback) {\n    // TODO Needs better checking\n    if (this.privKey &&\n      this.privKey.public &&\n      this.privKey.public.bytes &&\n      Buffer.isBuffer(this.pubKey.bytes) &&\n      this.privKey.public.bytes.equals(this.pubKey.bytes)) {\n      callback()\n    } else {\n      callback(new Error('Keys not match'))\n    }\n  }\n}\n\nconst PeerIdWithIs = withIs(PeerId, { className: 'PeerId', symbolName: '@libp2p/js-peer-id/PeerId' })\n\nexports = module.exports = PeerIdWithIs\n\nconst computeDigest = (pubKey, cb) => {\n  if (pubKey.bytes.length <= 42) {\n    const digest = mh.encode(pubKey.bytes, 'identity')\n    cb(null, digest)\n  } else {\n    pubKey.hash((err, digest) => {\n      cb(err, digest)\n    })\n  }\n}\n\nconst computePeerId = (privKey, pubKey, cb) => {\n  computeDigest(pubKey, (err, digest) => {\n    if (err != null) {\n      cb(err)\n    } else {\n      cb(null, new PeerIdWithIs(digest, privKey, pubKey))\n    }\n  })\n}\n\n// generation\nexports.create = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  }\n  opts = opts || {}\n  opts.bits = opts.bits || 2048\n  opts.keyType = opts.keyType || 'RSA'\n\n  cryptoKeys.generateKeyPair(opts.keyType, opts.bits, (err, privKey) => {\n    if (err != null) {\n      callback(err)\n    } else {\n      computePeerId(privKey, privKey.public, callback)\n    }\n  })\n}\n\nexports.createFromHexString = function (str) {\n  return new PeerIdWithIs(mh.fromHexString(str))\n}\n\nexports.createFromBytes = function (buf) {\n  return new PeerIdWithIs(buf)\n}\n\nexports.createFromB58String = function (str) {\n  return new PeerIdWithIs(mh.fromB58String(str))\n}\n\n// Public Key input will be a buffer\nexports.createFromPubKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let pubKey\n\n  try {\n    let buf = key\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n\n    pubKey = cryptoKeys.unmarshalPublicKey(buf)\n  } catch (err) {\n    return callback(err)\n  }\n\n  computePeerId(null, pubKey, callback)\n}\n\n// Private key input will be a string\nexports.createFromPrivKey = function (key, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let buf = key\n\n  try {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(key, 'base64')\n    }\n\n    if (!Buffer.isBuffer(buf)) throw new Error('Supplied key is neither a base64 string nor a buffer')\n  } catch (err) {\n    return callback(err)\n  }\n\n  cryptoKeys.unmarshalPrivateKey(buf, (err, privKey) => {\n    if (err != null) {\n      callback(err)\n    } else {\n      computePeerId(privKey, privKey.public, callback)\n    }\n  })\n}\n\nexports.createFromJSON = function (obj, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('callback is required')\n  }\n\n  let id\n  let rawPrivKey\n  let rawPubKey\n  let pub\n\n  try {\n    id = mh.fromB58String(obj.id)\n    rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64')\n    rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64')\n    pub = rawPubKey && cryptoKeys.unmarshalPublicKey(rawPubKey)\n  } catch (err) {\n    return callback(err)\n  }\n\n  if (!rawPrivKey) {\n    callback(null, new PeerIdWithIs(id, null, pub))\n    return\n  }\n\n  waterfall([\n    (cb) => cryptoKeys.unmarshalPrivateKey(rawPrivKey, cb),\n    (priv, cb) => {\n      computeDigest(priv.public, (err, digest) => {\n        cb(err, digest, priv)\n      })\n    },\n    (privDigest, priv, cb) => {\n      if (pub) {\n        computeDigest(pub, (err, pubDigest) => {\n          cb(err, privDigest, priv, pubDigest)\n        })\n      } else {\n        cb(null, privDigest, priv)\n      }\n    }\n  ], (err, privDigest, priv, pubDigest) => {\n    if (err) {\n      return callback(err)\n    }\n\n    if (pub && !privDigest.equals(pubDigest)) {\n      return callback(new Error('Public and private key do not match'))\n    }\n\n    if (id && !privDigest.equals(id)) {\n      return callback(new Error('Id and private key do not match'))\n    }\n\n    callback(null, new PeerIdWithIs(id, priv, pub))\n  })\n}\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' &&\n    peerId._id &&\n    peerId._idB58String)\n}\n\nfunction toB64Opt (val) {\n  if (val) {\n    return val.toString('base64')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}