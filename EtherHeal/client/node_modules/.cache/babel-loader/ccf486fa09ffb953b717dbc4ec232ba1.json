{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst Decoder = require('./decoder');\n\nconst utils = require('./utils');\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n */\n\n\nclass Diagnose extends Decoder {\n  createTag(tagNumber, value) {\n    return `${tagNumber}(${value})`;\n  }\n\n  createInt(val) {\n    return super.createInt(val).toString();\n  }\n\n  createInt32(f, g) {\n    return super.createInt32(f, g).toString();\n  }\n\n  createInt64(f1, f2, g1, g2) {\n    return super.createInt64(f1, f2, g1, g2).toString();\n  }\n\n  createInt32Neg(f, g) {\n    return super.createInt32Neg(f, g).toString();\n  }\n\n  createInt64Neg(f1, f2, g1, g2) {\n    return super.createInt64Neg(f1, f2, g1, g2).toString();\n  }\n\n  createTrue() {\n    return 'true';\n  }\n\n  createFalse() {\n    return 'false';\n  }\n\n  createFloat(val) {\n    const fl = super.createFloat(val);\n\n    if (utils.isNegativeZero(val)) {\n      return '-0_1';\n    }\n\n    return `${fl}_1`;\n  }\n\n  createFloatSingle(a, b, c, d) {\n    const fl = super.createFloatSingle(a, b, c, d);\n    return `${fl}_2`;\n  }\n\n  createFloatDouble(a, b, c, d, e, f, g, h) {\n    const fl = super.createFloatDouble(a, b, c, d, e, f, g, h);\n    return `${fl}_3`;\n  }\n\n  createByteString(raw, len) {\n    const val = raw.join(', ');\n\n    if (len === -1) {\n      return `(_ ${val})`;\n    }\n\n    return `h'${val}`;\n  }\n\n  createByteStringFromHeap(start, end) {\n    const val = Buffer.from(super.createByteStringFromHeap(start, end)).toString('hex');\n    return `h'${val}'`;\n  }\n\n  createInfinity() {\n    return 'Infinity_1';\n  }\n\n  createInfinityNeg() {\n    return '-Infinity_1';\n  }\n\n  createNaN() {\n    return 'NaN_1';\n  }\n\n  createNaNNeg() {\n    return '-NaN_1';\n  }\n\n  createNull() {\n    return 'null';\n  }\n\n  createUndefined() {\n    return 'undefined';\n  }\n\n  createSimpleUnassigned(val) {\n    return `simple(${val})`;\n  }\n\n  createArray(arr, len) {\n    const val = super.createArray(arr, len);\n\n    if (len === -1) {\n      // indefinite\n      return `[_ ${val.join(', ')}]`;\n    }\n\n    return `[${val.join(', ')}]`;\n  }\n\n  createMap(map, len) {\n    const val = super.createMap(map);\n    const list = Array.from(val.keys()).reduce(collectObject(val), '');\n\n    if (len === -1) {\n      return `{_ ${list}}`;\n    }\n\n    return `{${list}}`;\n  }\n\n  createObject(obj, len) {\n    const val = super.createObject(obj);\n    const map = Object.keys(val).reduce(collectObject(val), '');\n\n    if (len === -1) {\n      return `{_ ${map}}`;\n    }\n\n    return `{${map}}`;\n  }\n\n  createUtf8String(raw, len) {\n    const val = raw.join(', ');\n\n    if (len === -1) {\n      return `(_ ${val})`;\n    }\n\n    return `\"${val}\"`;\n  }\n\n  createUtf8StringFromHeap(start, end) {\n    const val = Buffer.from(super.createUtf8StringFromHeap(start, end)).toString('utf8');\n    return `\"${val}\"`;\n  }\n\n  static diagnose(input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex');\n    }\n\n    const dec = new Diagnose();\n    return dec.decodeFirst(input);\n  }\n\n}\n\nmodule.exports = Diagnose;\n\nfunction collectObject(val) {\n  return (acc, key) => {\n    if (acc) {\n      return `${acc}, ${key}: ${val[key]}`;\n    }\n\n    return `${key}: ${val[key]}`;\n  };\n}","map":{"version":3,"sources":["Z:/Projects/Organ-Donation-Transplant-Chain-master/Complete Project/client/node_modules/borc/src/diagnose.js"],"names":["Buffer","require","Decoder","utils","Diagnose","createTag","tagNumber","value","createInt","val","toString","createInt32","f","g","createInt64","f1","f2","g1","g2","createInt32Neg","createInt64Neg","createTrue","createFalse","createFloat","fl","isNegativeZero","createFloatSingle","a","b","c","d","createFloatDouble","e","h","createByteString","raw","len","join","createByteStringFromHeap","start","end","from","createInfinity","createInfinityNeg","createNaN","createNaNNeg","createNull","createUndefined","createSimpleUnassigned","createArray","arr","createMap","map","list","Array","keys","reduce","collectObject","createObject","obj","Object","createUtf8String","createUtf8StringFromHeap","diagnose","input","enc","dec","decodeFirst","module","exports","acc","key"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { Buffer } = require('buffer')\nconst Decoder = require('./decoder')\nconst utils = require('./utils')\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n */\nclass Diagnose extends Decoder {\n  createTag (tagNumber, value) {\n    return `${tagNumber}(${value})`\n  }\n\n  createInt (val) {\n    return super.createInt(val).toString()\n  }\n\n  createInt32 (f, g) {\n    return super.createInt32(f, g).toString()\n  }\n\n  createInt64 (f1, f2, g1, g2) {\n    return super.createInt64(f1, f2, g1, g2).toString()\n  }\n\n  createInt32Neg (f, g) {\n    return super.createInt32Neg(f, g).toString()\n  }\n\n  createInt64Neg (f1, f2, g1, g2) {\n    return super.createInt64Neg(f1, f2, g1, g2).toString()\n  }\n\n  createTrue () {\n    return 'true'\n  }\n\n  createFalse () {\n    return 'false'\n  }\n\n  createFloat (val) {\n    const fl = super.createFloat(val)\n    if (utils.isNegativeZero(val)) {\n      return '-0_1'\n    }\n\n    return `${fl}_1`\n  }\n\n  createFloatSingle (a, b, c, d) {\n    const fl = super.createFloatSingle(a, b, c, d)\n    return `${fl}_2`\n  }\n\n  createFloatDouble (a, b, c, d, e, f, g, h) {\n    const fl = super.createFloatDouble(a, b, c, d, e, f, g, h)\n    return `${fl}_3`\n  }\n\n  createByteString (raw, len) {\n    const val = raw.join(', ')\n\n    if (len === -1) {\n      return `(_ ${val})`\n    }\n    return `h'${val}`\n  }\n\n  createByteStringFromHeap (start, end) {\n    const val = (Buffer.from(\n      super.createByteStringFromHeap(start, end)\n    )).toString('hex')\n\n    return `h'${val}'`\n  }\n\n  createInfinity () {\n    return 'Infinity_1'\n  }\n\n  createInfinityNeg () {\n    return '-Infinity_1'\n  }\n\n  createNaN () {\n    return 'NaN_1'\n  }\n\n  createNaNNeg () {\n    return '-NaN_1'\n  }\n\n  createNull () {\n    return 'null'\n  }\n\n  createUndefined () {\n    return 'undefined'\n  }\n\n  createSimpleUnassigned (val) {\n    return `simple(${val})`\n  }\n\n  createArray (arr, len) {\n    const val = super.createArray(arr, len)\n\n    if (len === -1) {\n      // indefinite\n      return `[_ ${val.join(', ')}]`\n    }\n\n    return `[${val.join(', ')}]`\n  }\n\n  createMap (map, len) {\n    const val = super.createMap(map)\n    const list = Array.from(val.keys())\n      .reduce(collectObject(val), '')\n\n    if (len === -1) {\n      return `{_ ${list}}`\n    }\n\n    return `{${list}}`\n  }\n\n  createObject (obj, len) {\n    const val = super.createObject(obj)\n    const map = Object.keys(val)\n      .reduce(collectObject(val), '')\n\n    if (len === -1) {\n      return `{_ ${map}}`\n    }\n\n    return `{${map}}`\n  }\n\n  createUtf8String (raw, len) {\n    const val = raw.join(', ')\n\n    if (len === -1) {\n      return `(_ ${val})`\n    }\n\n    return `\"${val}\"`\n  }\n\n  createUtf8StringFromHeap (start, end) {\n    const val = (Buffer.from(\n      super.createUtf8StringFromHeap(start, end)\n    )).toString('utf8')\n\n    return `\"${val}\"`\n  }\n\n  static diagnose (input, enc) {\n    if (typeof input === 'string') {\n      input = Buffer.from(input, enc || 'hex')\n    }\n\n    const dec = new Diagnose()\n    return dec.decodeFirst(input)\n  }\n}\n\nmodule.exports = Diagnose\n\nfunction collectObject (val) {\n  return (acc, key) => {\n    if (acc) {\n      return `${acc}, ${key}: ${val[key]}`\n    }\n    return `${key}: ${val[key]}`\n  }\n}\n"]},"metadata":{},"sourceType":"script"}